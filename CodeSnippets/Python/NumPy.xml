<?xml version="1.0"?>
<block name="Python" source="http://python.org/" syntax="python" tags="python">
  <block name="NumPy" source="http://www.numpy.org/" tags="numpy">
    <prerequisites><![CDATA[from numpy import *]]></prerequisites>
    <block name="Array" tags="array ndarray">
      <code tags="create row"><![CDATA[data = array([0.1, 0.2, 0.3])
data

# array([0.1, 0.2, 0.3])]]></code>
      <code tags="create col column"><![CDATA[data = array([[0.1], [0.2], [0.3]])
data

# array([[ 0.1],
#        [ 0.2],
#        [ 0.3]])]]></code>
      <code tags="create 2d matrix multidimensional"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data

# array([[ 0.1,  0.2,  0.3],
#        [ 0.4,  0.5,  0.6]])]]></code>
      <code tags="add addition plus scalar constant"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data + 1

# array([[ 1.1,  1.2,  1.3],
#        [ 1.4,  1.5,  1.6]])]]></code>
      <code tags="add addition plus"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data + data

# array([[ 0.2,  0.4,  0.6],
#        [ 0.8,  1. ,  1.2]])]]></code>
      <code tags="add addition plus broadcasting row"><![CDATA[data1 = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data2 = array([1., 2., 3.])
data1 + data2

# array([[ 1.1,  2.2,  3.3],
#        [ 1.4,  2.5,  3.6]])]]></code>
      <code tags="add addition plus broadcasting col column"><![CDATA[data1 = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data2 = array([[1.], [2.]])
data1 + data2

# array([[ 1.1,  1.2,  1.3],
#        [ 2.4,  2.5,  2.6]])]]></code>
      <code tags="ndim number dimensions axes rank"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.ndim

# 2]]></code>
      <code tags="shape dimensions"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.shape

# (2L, 3L)]]></code>
      <code tags="size total number elements"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.size

# 6]]></code>
      <code tags="itemsize size bytes"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.itemsize

# 8]]></code>
      <code tags="buffer data"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.data

# <read-write buffer for 0x0000000008886F40, size 48, offset 0 at 0x00000000088CEB58>]]></code>
      <code tags="type"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
type(data)

# numpy.ndarray]]></code>
      <code tags="arange range sequence"><![CDATA[arange(10)

# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])]]></code>
      <code tags="arange range sequence reshape"><![CDATA[arange(10).reshape(2,5)

# array([[0, 1, 2, 3, 4],
#        [5, 6, 7, 8, 9]])]]></code>
      <code tags="arange range sequence reshape"><![CDATA[arange(10).reshape((2,5))

# array([[0, 1, 2, 3, 4],
#        [5, 6, 7, 8, 9]])]]></code>
      <code tags="arange range sequence"><![CDATA[arange(10, 30, 5)

# array([10, 15, 20, 25])]]></code>
      <code tags="arange range sequence float"><![CDATA[arange(0, 2, 0.3)

# array([ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8])]]></code>
      <code tags="linspace interval range"><![CDATA[linspace(0, 2, 9)

# array([ 0.  ,  0.25,  0.5 ,  0.75,  1.  ,  1.25,  1.5 ,  1.75,  2.  ])]]></code>
      <code tags="print 1d"><![CDATA[print arange(8)

# [0 1 2 3 4 5 6 7]]]></code>
      <code tags="print 1d big large"><![CDATA[print arange(10000)

# [   0    1    2 ..., 9997 9998 9999]]]></code>
      <code tags="print 2d reshape"><![CDATA[print arange(12).reshape(4,3)

# [[ 0  1  2]
#  [ 3  4  5]
#  [ 6  7  8]
#  [ 9 10 11]]]]></code>
      <code tags="print 2d reshape big large"><![CDATA[print arange(10000).reshape(100,100)

# [[   0    1    2 ...,   97   98   99]
#  [ 100  101  102 ...,  197  198  199]
#  [ 200  201  202 ...,  297  298  299]
#  ..., 
#  [9700 9701 9702 ..., 9797 9798 9799]
#  [9800 9801 9802 ..., 9897 9898 9899]
#  [9900 9901 9902 ..., 9997 9998 9999]]]]></code>
      <code tags="print 3d reshape"><![CDATA[print arange(24).reshape(2,3,4)

# [[[ 0  1  2  3]
#   [ 4  5  6  7]
#   [ 8  9 10 11]]
# 
#  [[12 13 14 15]
#   [16 17 18 19]
#   [20 21 22 23]]]]]></code>
      <code tags="zeros"><![CDATA[zeros(10)

# array([ 0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.,  0.])]]></code>
      <code tags="zeros 2d matrix multidimensional"><![CDATA[zeros((2,4))

# array([[ 0.,  0.,  0.,  0.],
#        [ 0.,  0.,  0.,  0.]])]]></code>
      <code tags="zeros like"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
zeros_like(data)

# array([[ 0.,  0.,  0.],
#        [ 0.,  0.,  0.]])]]></code>
      <code tags="ones"><![CDATA[ones(10)

# array([ 1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.,  1.])]]></code>
      <code tags="ones 2d matrix multidimensional"><![CDATA[ones((2,4))

# array([[ 1.,  1.,  1.,  1.],
#        [ 1.,  1.,  1.,  1.]])]]></code>
      <code tags="ones like"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
ones_like(data)

# array([[ 1.,  1.,  1.],
#        [ 1.,  1.,  1.]])]]></code>
      <code tags="empty"><![CDATA[empty(3)

# array([  2.21650179e-301,   1.24182589e-307,   3.66286673e-316])]]></code>
      <code tags="empty 2d matrix multidimensional"><![CDATA[empty((3,2))

# array([[  1.52183474e-316,   1.52478856e-316],
#        [  2.50008035e-315,   7.02096887e-316],
#        [  8.14120165e-315,   1.52483362e-316]])]]></code>
      <code tags="empty like"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
empty_like(data)

# array([[  1.78851764e-321,   6.39175467e-314,   2.57675195e-316],
#        [  2.96439388e-323,   1.91237288e-313,   4.94065646e-323]])]]></code>
      <code tags="eye identity matrix"><![CDATA[eye(4)

# array([[ 1.,  0.,  0.,  0.],
#        [ 0.,  1.,  0.,  0.],
#        [ 0.,  0.,  1.,  0.],
#        [ 0.,  0.,  0.,  1.]])]]></code>
      <code tags="eye identity matrix"><![CDATA[identity(4)

# array([[ 1.,  0.,  0.,  0.],
#        [ 0.,  1.,  0.,  0.],
#        [ 0.,  0.,  1.,  0.],
#        [ 0.,  0.,  0.,  1.]])]]></code>
      <code tags="eye identity rectangle matrix"><![CDATA[eye(2,4)

# array([[ 1.,  0.,  0.,  0.],
#        [ 0.,  1.,  0.,  0.]])]]></code>
      <code tags="eye identity rectangle matrix"><![CDATA[identity(2,4)

# array([[ 1.,  0.,  0.,  0.],
#        [ 0.,  1.,  0.,  0.]])]]></code>
      <code tags="astype convert int float"><![CDATA[# Note: Calling astype always creates a new array (a copy of the data).

data = array([1, 2, 3, 4, 5])
data.dtype

# dtype('int32')

float_data = data.astype(float64)
float_data.dtype

# dtype('float64')]]></code>
      <code tags="astype convert int float"><![CDATA[# Note: Calling astype always creates a new array (a copy of the data).

data = array([1.6, -2.5, 3.2, 0.1])
data.dtype

# dtype('float64')

int_data = data.astype(int32)
int_data

# array([ 1, -2,  3,  0])]]></code>
      <code tags="astype convert string float"><![CDATA[# Note: Calling astype always creates a new array (a copy of the data).

data = array(['1.6', '-2.5', '3.2', '0.1'])
data.dtype

# dtype('S4')

float_data = data.astype(float64)
float_data

# array([ 1.6, -2.5,  3.2,  0.1])]]></code>
      <code tags="mesh grid meshgrid 2d"><![CDATA[xs, ys = meshgrid(array([1, 2, 3, 4]), array([0.1, 0.2, 0.3]))
xs

# array([[1, 2, 3, 4],
#        [1, 2, 3, 4],
#        [1, 2, 3, 4]])

ys

# array([[ 0.1,  0.1,  0.1,  0.1],
#        [ 0.2,  0.2,  0.2,  0.2],
#        [ 0.3,  0.3,  0.3,  0.3]])]]></code>
      <block name="Data Types" tags="dtype type">
        <code tags="int int32"><![CDATA[data = array([1, 2, 3])
data.dtype

# dtype('int32')]]></code>
        <code tags="int int64"><![CDATA[data = array([[1, 2, 3], [4, 5, 6]], dtype=int64)
data.dtype

# dtype('int64')]]></code>
        <code tags="float float64"><![CDATA[data = array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])
data.dtype

# dtype('float64')]]></code>
        <code tags="float float64"><![CDATA[data = array([1, 2, 3], dtype=float64)
data.dtype

# dtype('float64')]]></code>
        <code tags="int integer signed"><![CDATA[# Type
data = array([1, 2, 3], dtype=int8)   # Signed 8-bit (1 byte) integer type
data = array([1, 2, 3], dtype=int16)  # Signed 16-bit integer type
data = array([1, 2, 3], dtype=int32)  # Signed 32-bit integer type
data = array([1, 2, 3], dtype=int64)  # Signed 64-bit integer type

# Type Code
data = array([1, 2, 3], dtype='i1')   # Signed 8-bit (1 byte) integer type
data = array([1, 2, 3], dtype='i2')   # Signed 16-bit integer type
data = array([1, 2, 3], dtype='i4')   # Signed 32-bit integer type
data = array([1, 2, 3], dtype='i8')   # Signed 64-bit integer type]]></code>
        <code tags="uint integer unsigned"><![CDATA[# Type
data = array([1, 2, 3], dtype=uint8)  # Unsigned 8-bit (1 byte) integer type
data = array([1, 2, 3], dtype=uint16) # Unsigned 16-bit integer type
data = array([1, 2, 3], dtype=uint32) # Unsigned 32-bit integer type
data = array([1, 2, 3], dtype=uint64) # Unsigned 64-bit integer type

# Type Code
data = array([1, 2, 3], dtype='u1')   # Unsigned 8-bit (1 byte) integer type
data = array([1, 2, 3], dtype='u2')   # Unsigned 16-bit integer type
data = array([1, 2, 3], dtype='u4')   # Unsigned 32-bit integer type
data = array([1, 2, 3], dtype='u8')   # Unsigned 64-bit integer type]]></code>
        <code tags="float double precision"><![CDATA[# Type
data = array([1, 2, 3], dtype=float16)  # Half-precision floating point
data = array([1, 2, 3], dtype=float32)  # Standard single-precision floating point. Compatible with C float
data = array([1, 2, 3], dtype=float64)  # Standard double-precision floating point. Compatible with C double and Python float object
data = array([1, 2, 3], dtype=float128) # Extended-precision floating point

# Type Code
data = array([1, 2, 3], dtype='f2')  # Half-precision floating point
data = array([1, 2, 3], dtype='f4')  # Standard single-precision floating point. Compatible with C float
data = array([1, 2, 3], dtype='f')   # Standard single-precision floating point. Compatible with C float
data = array([1, 2, 3], dtype='f8')  # Standard double-precision floating point. Compatible with C double and Python float object
data = array([1, 2, 3], dtype='d')   # Standard double-precision floating point. Compatible with C double and Python float object
data = array([1, 2, 3], dtype='f16') # Extended-precision floating point
data = array([1, 2, 3], dtype='g')   # Extended-precision floating point]]></code>
        <code tags="complex"><![CDATA[# Type
data = array([1, 2, 3], dtype=complex64)  # Standard single-precision complex number
data = array([1, 2, 3], dtype=complex128) # Standard double-precision complex number
data = array([1, 2, 3], dtype=complex256) # Extended-precision complex number

# Type Code
data = array([1, 2, 3], dtype='c8')       # Standard single-precision complex number
data = array([1, 2, 3], dtype='c16')      # Standard double-precision complex number
data = array([1, 2, 3], dtype='c32')      # Extended-precision complex number]]></code>
        <code tags="bool boolean true false"><![CDATA[data = array([True, True, False], dtype=bool) # Boolean type storing True and False values
data = array([True, True, False], dtype='?')  # Boolean type storing True and False values]]></code>
        <code tags="object"><![CDATA[data = array(['Hello', 1, 0.5], dtype=object) # Python object type
data = array(['Hello', 1, 0.5], dtype='O')    # Python object type]]></code>
        <code tags="string"><![CDATA[data = array(['Hello', 'NumPy'], dtype=string_) # Fixed-length string type (1 byte per character)
data = array(['Hello', 'NumPy'], dtype='S5')    # To create a string dtype with length 10, use 'S10']]></code>
        <code tags="unicode string"><![CDATA[data = array(['Hello', 'NumPy'], dtype=unicode_) # Fixed-length unicode type (number of bytes platform specific)
data = array(['Hello', 'NumPy'], dtype='U5')     # To create a unicode string dtype with length 10, use 'U10']]></code>
      </block>
      <block name="Operations" tags="operation scalar elementwise">
        <prerequisites><![CDATA[data = array([[1., 2., 3.], [4., 5., 6.]])]]></prerequisites>
        <code tags="add addition plus"><![CDATA[data + data

# array([[  2.,   4.,   6.],
#        [  8.,  10.,  12.]])]]></code>
        <code tags="add addition plus scalar"><![CDATA[data + 1

# array([[ 2.,  3.,  4.],
#        [ 5.,  6.,  7.]])]]></code>
        <code tags="minus sub substraction"><![CDATA[data - data

# array([[ 0.,  0.,  0.],
#        [ 0.,  0.,  0.]])]]></code>
        <code tags="minus sub substraction scalar"><![CDATA[data - 1

# array([[ 0.,  1.,  2.],
#        [ 3.,  4.,  5.]])]]></code>
        <code tags="prod product mul multiplication"><![CDATA[data * data

# array([[  1.,   4.,   9.],
#        [ 16.,  25.,  36.]])]]></code>
        <code tags="prod product mul multiplication scalar"><![CDATA[data * 2

# array([[  2.,   4.,   6.],
#        [  8.,  10.,  12.]])]]></code>
        <code tags="div division"><![CDATA[data / data

# array([[ 1.,  1.,  1.],
#        [ 1.,  1.,  1.]])]]></code>
        <code tags="div division scalar"><![CDATA[1 / data

# array([[ 1.        ,  0.5       ,  0.33333333],
#        [ 0.25      ,  0.2       ,  0.16666667]])]]></code>
        <code tags="exp exponentiation scalar"><![CDATA[data ** 0.5

# array([[ 1.        ,  1.41421356,  1.73205081],
#        [ 2.        ,  2.23606798,  2.44948974]])]]></code>
        <code tags="sin sine sinus function"><![CDATA[sin(data)

# array([[ 0.84147098,  0.90929743,  0.14112001],
#        [-0.7568025 , -0.95892427, -0.2794155 ]])]]></code>
        <code tags="cos cosine cosinus function"><![CDATA[cos(data)

# array([[ 0.54030231, -0.41614684, -0.9899925 ],
#        [-0.65364362,  0.28366219,  0.96017029]])]]></code>
        <code tags="bool boolean"><![CDATA[data > 2

# array([[False, False,  True],
#        [ True,  True,  True]], dtype=bool)]]></code>
        <code tags="sum add"><![CDATA[data.sum()

# 21.0]]></code>
        <code tags="prod product mul multiply"><![CDATA[data.prod()

# 720.0]]></code>
        <code tags="cumsum cummulative sum add"><![CDATA[data.cumsum()

# array([  1.,   3.,   6.,  10.,  15.,  21.])]]></code>
        <code tags="cumprod cummulative prod product mul multiply"><![CDATA[data.cumprod()

# array([   1.,    2.,    6.,   24.,  120.,  720.])]]></code>
        <code tags="min minimum"><![CDATA[data.min()

# 1.0]]></code>
        <code tags="max maximum"><![CDATA[data.max()

# 6.0]]></code>
        <code tags="sum add axis rows"><![CDATA[data.sum(axis=0)

# array([ 5.,  7.,  9.])]]></code>
        <code tags="prod product mul multiply axis rows"><![CDATA[data.prod(axis=0)

# array([  4.,  10.,  18.])]]></code>
        <code tags="cumsum cummulative sum add axis rows"><![CDATA[data.cumsum(axis=0)

# array([[ 1.,  2.,  3.],
#        [ 5.,  7.,  9.]])]]></code>
        <code tags="cumprod cummulative prod product mul multiply axis rows"><![CDATA[data.cumprod(axis=0)

# array([[  1.,   2.,   3.],
#        [  4.,  10.,  18.]])]]></code>
        <code tags="min minimum axis rows"><![CDATA[data.min(axis=0)

# array([ 1.,  2.,  3.])]]></code>
        <code tags="max maximum axis rows"><![CDATA[data.max(axis=0)

# array([ 4.,  5.,  6.])]]></code>
        <code tags="sum add axis cols columns"><![CDATA[data.sum(axis=1)

# array([  6.,  15.])]]></code>
        <code tags="prod product mul multiply axis cols columns"><![CDATA[data.prod(axis=1)

# array([   6.,  120.])]]></code>
        <code tags="cumsum cummulative sum add axis cols columns"><![CDATA[data.cumsum(axis=1)

# array([[  1.,   3.,   6.],
#        [  4.,   9.,  15.]])]]></code>
        <code tags="cumprod cummulative prod product mul multiply axis cols columns"><![CDATA[data.cumprod(axis=1)

# array([[   1.,    2.,    6.],
#        [   4.,   20.,  120.]])]]></code>
        <code tags="min minimum axis cols columns"><![CDATA[data.min(axis=1)

# array([ 1.,  4.])]]></code>
        <code tags="max maximum axis cols columns"><![CDATA[data.max(axis=1)

# array([ 3.,  6.])]]></code>
      </block>
      <block name="Indexing and Slicing" tags="select slicing indexing">
        <prerequisites><![CDATA[# Array slices are views on the original array. This means that 
# the modifications to the view will be reflected in the source.]]></prerequisites>
        <block name="Simple" tags="1d one dim dimensional">
          <prerequisites><![CDATA[data = arange(10)
data
# array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])]]></prerequisites>
          <code tags="index"><![CDATA[data[3]

# 3]]></code>
          <code tags="index assign"><![CDATA[data[3] = 10
data

# array([ 0,  1,  2, 10,  4,  5,  6,  7,  8,  9])]]></code>
          <code tags="slice"><![CDATA[data[4:7]

# array([4, 5, 6])]]></code>
          <code tags="slice assign"><![CDATA[data[4:7] = 10
data

# array([ 0,  1,  2,  3, 10, 10, 10,  7,  8,  9])]]></code>
          <code tags="slice assign"><![CDATA[data[:] = 10
data

# array([10, 10, 10, 10, 10, 10, 10, 10, 10, 10])]]></code>
          <code tags="slice assign"><![CDATA[data_slice = data[4:7]
data_slice

# array([4, 5, 6])

data_slice[0:2] = 10
data

# array([ 0,  1,  2,  3, 10, 10,  6,  7,  8,  9])]]></code>
        </block>
        <block name="Multi" tags="2d 3d two dim dimensional multidimensional">
          <code tags="index row"><![CDATA[data = array([[ 1.,  2.,  3.], [ 4.,  5.,  6.]])
data[1]

# array([ 4.,  5.,  6.])]]></code>
          <code tags="index element"><![CDATA[data = array([[ 1.,  2.,  3.], [ 4.,  5.,  6.]])
data[1][0]

# 4.0]]></code>
          <code tags="index element"><![CDATA[data = array([[ 1.,  2.,  3.], [ 4.,  5.,  6.]])
data[1,0]

# 4.0]]></code>
          <code tags="index assign"><![CDATA[data3d = array([[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])
data3d[0]

# array([[1, 2, 3],
#        [4, 5, 6]])

data3d[0] = 0
data3d

# array([[[ 0,  0,  0],
#         [ 0,  0,  0]],
# 
#        [[ 7,  8,  9],
#         [10, 11, 12]]])]]></code>
          <code tags="slice row column"><![CDATA[data = arange(9).reshape(3,3)
data

# array([[0, 1, 2],
#        [3, 4, 5],
#        [6, 7, 8]])

data[:2, 1:]

# array([[1, 2],
#        [4, 5]])

data[2, :2]

# array([6, 7])

data[2:3, :2]

# array([[6, 7]])

data[:, 2]

# array([2, 5, 8])

data[:, 2:3]

# array([[2],
#        [5],
#        [8]])]]></code>
        </block>
        <block name="Boolean Mask" tags="boolean mask">
          <prerequisites><![CDATA[names = array(['A', 'B', 'A', 'A', 'B', 'C', 'B', 'C', 'A', 'B'])
data = arange(10)]]></prerequisites>
          <code tags="equal equality"><![CDATA[names == 'A'

# array([ True, False,  True,  True, False, False, False, False,  True, False], dtype=bool)]]></code>
          <code tags="equal equality"><![CDATA[data[names == 'A']

# array([0, 2, 3, 8])]]></code>
          <code tags="non equal equality"><![CDATA[names != 'A'

# array([False,  True, False, False,  True,  True,  True,  True, False,  True], dtype=bool)]]></code>
          <code tags="non equal equality"><![CDATA[data[names != 'A']

# array([1, 4, 5, 6, 7, 9])]]></code>
          <code tags="non equal equality"><![CDATA[data[-(names == 'A')]

# array([1, 4, 5, 6, 7, 9])]]></code>
          <code tags="mask or"><![CDATA[mask = (names == 'A') | (names == 'B')
mask

# array([ True,  True,  True,  True,  True, False,  True, False,  True,  True], dtype=bool)

data[mask]

# array([0, 1, 2, 3, 4, 6, 8, 9])]]></code>
        </block>
        <block name="Boolean Mask Multi" tags="2d 3d two dim dimensional multidimensional boolean mask">
          <prerequisites><![CDATA[names = array(['A', 'B', 'A', 'A', 'B'])
data = \
array([[ 0.99967699, -2.1012428 ,  1.75486491, -1.51122214],\
       [ 0.33066342,  2.23753523,  1.14904487,  1.16904971],\
       [ 0.16658431, -0.61043839, -1.12147585,  0.51585227],\
       [-0.5238359 ,  1.56868351, -0.32276508, -0.08403215],\
       [-0.18533686, -0.11829734,  0.08526658, -0.2188181 ]])]]></prerequisites>
          <code tags="equal equality"><![CDATA[data[names == 'A']

# array([[ 0.99967699, -2.1012428 ,  1.75486491, -1.51122214],
#        [ 0.16658431, -0.61043839, -1.12147585,  0.51585227],
#        [-0.5238359 ,  1.56868351, -0.32276508, -0.08403215]])]]></code>
          <code tags="equal equality assign"><![CDATA[data[names == 'A'] = 1
data

# array([[ 1.        ,  1.        ,  1.        ,  1.        ],
#        [ 0.33066342,  2.23753523,  1.14904487,  1.16904971],
#        [ 1.        ,  1.        ,  1.        ,  1.        ],
#        [ 1.        ,  1.        ,  1.        ,  1.        ],
#        [-0.18533686, -0.11829734,  0.08526658, -0.2188181 ]])]]></code>
          <code tags="inequality"><![CDATA[data < 0

# array([[False,  True, False,  True],
#        [False, False, False, False],
#        [False,  True,  True, False],
#        [ True, False,  True,  True],
#        [ True,  True, False,  True]], dtype=bool)]]></code>
          <code tags="inequality assign"><![CDATA[data[data < 0] = 0
data

# array([[ 0.99967699,  0.        ,  1.75486491,  0.        ],
#        [ 0.33066342,  2.23753523,  1.14904487,  1.16904971],
#        [ 0.16658431,  0.        ,  0.        ,  0.51585227],
#        [ 0.        ,  1.56868351,  0.        ,  0.        ],
#        [ 0.        ,  0.        ,  0.08526658,  0.        ]])]]></code>
        </block>
        <block name="Fancy" tags="fancy integer arrays">
          <prerequisites><![CDATA[data = array([[i]*4 for i in range(6)])]]></prerequisites>
          <code><![CDATA[data[[2, 0, 1]]

# array([[2, 2, 2, 2],
#        [0, 0, 0, 0],
#        [1, 1, 1, 1]])]]></code>
          <code><![CDATA[data[[-2, -3, -1]]

# array([[4, 4, 4, 4],
#        [3, 3, 3, 3],
#        [5, 5, 5, 5]])]]></code>
        </block>
        <block name="Fancy Multi" tags="2d 3d two dim dimensional multidimensional fancy integer arrays">
          <prerequisites><![CDATA[data = arange(20).reshape(5,4)]]></prerequisites>
          <code><![CDATA[data[[3,0,1,2],[1,0,2,2]]

# array([13,  0,  6, 10])]]></code>
          <code><![CDATA[data[[3,0,1,2]][:,[1,0,2,2]]

# array([[13, 12, 14, 14],
#        [ 1,  0,  2,  2],
#        [ 5,  4,  6,  6],
#        [ 9,  8, 10, 10]])]]></code>
        </block>
      </block>
    </block>
    <block name="Examples" tags="examples samples array ndarray">
      <description>http://wiki.scipy.org/Numpy_Example_List</description>
      <code tags="dots"><![CDATA[a = arange(12)
a = a.reshape(3,2,2)
print a

# [[[ 0  1]
#   [ 2  3]]
#  [[ 4  5]
#   [ 6  7]]
#  [[ 8  9]
#   [10 11]]]

a[...,0]  # same as a[:,:,0]

# array([[ 0,  2],
#        [ 4,  6],
#        [ 8, 10]])

a[1:,...] # same as a[1:,:,:] or just a[1:]

# array([[[ 4, 5],
#         [ 6, 7]],
#        [[ 8, 9],
#         [10, 11]]])]]></code>
      <code tags="square brackets index indexing slice slicing"><![CDATA[a = array([ [ 0, 1, 2, 3, 4],\
            [10,11,12,13,14],\
            [20,21,22,23,24],\
            [30,31,32,33,34] ])
a[0,0] # indices start by zero
# 0

a[-1] # last row
# array([30, 31, 32, 33, 34])

a[1:3,1:4] # subarray
# array([[11, 12, 13],
#        [21, 22, 23]])

i = array([0,1,2,1]) # array of indices for the first axis
j = array([1,2,3,4]) # array of indices for the second axis
a[i,j]
# array([ 1, 12, 23, 14])

a[a<13] # boolean indexing
# array([ 0, 1, 2, 3, 4, 10, 11, 12])

b1 = array( [True,False,True,False] ) # boolean row selector
a[b1,:]
# array([[ 0, 1, 2, 3, 4],
#        [20, 21, 22, 23, 24]])

b2 = array( [False,True,True,False,True] ) # boolean column selector
a[:,b2]
# array([[ 1, 2, 4],
#        [11, 12, 14],
#        [21, 22, 24],
#        [31, 32, 34]])]]></code>
      <code tags="abs absolute"><![CDATA[abs(-1)
# 1

abs(array([-1.2, 1.2]))
# array([ 1.2, 1.2])

abs(1.2+1j)
# 1.5620499351813308

absolute(1.2+1j)
# 1.5620499351813308]]></code>
      <code tags="accumulate add mul multiply axis rows cols columns"><![CDATA[add.accumulate(array([1.,2.,3.,4.])) # like reduce() but also gives intermediate results
# array([ 1., 3., 6., 10.])

array([1., 1.+2., (1.+2.)+3., ((1.+2.)+3.)+4.]) # this is what it computed
# array([ 1., 3., 6., 10.])

multiply.accumulate(array([1.,2.,3.,4.])) # works also with other operands
# array([ 1., 2., 6., 24.])

array([1., 1.*2., (1.*2.)*3., ((1.*2.)*3.)*4.]) # this is what it computed
# array([ 1., 2., 6., 24.])

add.accumulate(array([[1,2,3],[4,5,6]]), axis = 0) # accumulate every column separately
# array([[1, 2, 3],
#        [5, 7, 9]])

add.accumulate(array([[1,2,3],[4,5,6]]), axis = 1) # accumulate every row separately
# array([[ 1, 3, 6],
#        [ 4, 9, 15]])]]></code>
      <code tags="add plus"><![CDATA[add(array([-1.2, 1.2]), array([1,3]))
# array([-0.2, 4.2])

array([-1.2, 1.2]) + array([1,3])
# array([-0.2, 4.2])]]></code>
      <code tags="all elements true"><![CDATA[a = array([True, False, True])
a.all() # if all elements of a are True: return True; otherwise False
# False

all(a) # this form also exists
# False

a = array([1,2,3])
all(a > 0) # equivalent to (a > 0).all()
# True]]></code>
      <code tags="all elements close similar"><![CDATA[allclose(array([1e10,1e-7]), array([1.00001e10,1e-8]))
# False

allclose(array([1e10,1e-8]), array([1.00001e10,1e-9]))
# True

allclose(array([1e10,1e-8]), array([1.0001e10,1e-9]))
# False]]></code>
      <code tags="all elements true alltrue"><![CDATA[b = array([True, False, True, True])
alltrue(b)
# False

a = array([1, 5, 2, 7])
alltrue(a >= 5)
# False]]></code>
      <code tags="angle rad radians deg degrees"><![CDATA[angle(1+1j) # in radians
# 0.78539816339744828

angle(1+1j,deg=True) # in degrees
# 45.0]]></code>
      <code tags="any at least one exists some"><![CDATA[a = array([True, False, True])
a.any() # gives True if at least 1 element of a is True, otherwise False
# True

any(a) # this form also exists
# True

a = array([1,2,3])
(a >= 1).any() # equivalent to any(a >= 1)
# True]]></code>
      <code tags="append add concatenate axis rows cols columns"><![CDATA[a = array([10,20,30,40])
append(a,50)
# array([10, 20, 30, 40, 50])

append(a,[50,60])
# array([10, 20, 30, 40, 50, 60])

a = array([[10,20,30],[40,50,60],[70,80,90]])
append(a,[[15,15,15]],axis=0)
# array([[10, 20, 30],
#        [40, 50, 60],
#        [70, 80, 90],
#        [15, 15, 15]])

append(a,[[15],[15],[15]],axis=1)
# array([[10, 20, 30, 15],
#        [40, 50, 60, 15],
#        [70, 80, 90, 15]])]]></code>
      <code tags="apply custom function along axis rows cols columns"><![CDATA[def myfunc(a): # function works on a 1d arrays, takes the average of the 1st an last element
  return (a[0]+a[-1])/2

b = array([[1,2,3],[4,5,6],[7,8,9]])
apply_along_axis(myfunc,0,b) # apply myfunc to each column (axis=0) of b
# array([4, 5, 6])

apply_along_axis(myfunc,1,b) # apply myfunc to each row (axis=1) of b
# array([2, 5, 8])]]></code>
      <code tags="apply function over specific axes axis"><![CDATA[a = arange(24).reshape(2,3,4) # a has 3 axes: 0,1 and 2
a
# array([[[ 0, 1, 2, 3],
#         [ 4, 5, 6, 7],
#         [ 8, 9, 10, 11]],
#        [[12, 13, 14, 15],
#         [16, 17, 18, 19],
#         [20, 21, 22, 23]]])

apply_over_axes(sum, a, [0,2]) # sum over all axes except axis=1, result has same shape as original
# array([[[ 60],
#         [ 92],
#         [124]]])]]></code>
      <code tags="arange range sequence start stop step arrayrange"><![CDATA[arange(3)
# array([0, 1, 2])

arange(3.0)
# array([ 0., 1., 2.])

arange(3, dtype=float)
# array([ 0., 1., 2.])

arange(3,10) # start,stop
# array([3, 4, 5, 6, 7, 8, 9])

arange(3,10,2) # start,stop,step
# array([3, 5, 7, 9])]]></code>
      <code tags="arccos arcus cosinus inverse"><![CDATA[arccos(array([0, 1]))
# array([ 1.57079633, 0. ])]]></code>
      <code tags="arccosh arcus cosinus hyperbolic inverse"><![CDATA[arccosh(array([e, 10.0]))
# array([ 1.65745445, 2.99322285])]]></code>
      <code tags="arcsin arcus sinus inverse"><![CDATA[arcsin(array([0, 1]))
# array([ 0. , 1.57079633])]]></code>
      <code tags="arcsin arcus sinus hyperbolic inverse"><![CDATA[arcsinh(array([e, 10.0]))
# array([ 1.72538256, 2.99822295])]]></code>
      <code tags="arctan arcus tangens inverse"><![CDATA[arctan(array([0, 1]))
# array([ 0. , 0.78539816])]]></code>
      <code tags="arctan2 arcus tangens inverse"><![CDATA[arctan2(array([0, 1]), array([1, 0]))
# array([ 0. , 1.57079633])]]></code>
      <code tags="arctanh arcus tangens hyperbolic inverse"><![CDATA[arctanh(array([0, -0.5]))
# array([ 0. , -0.54930614])]]></code>
      <code tags="argmax argument max maximum axis rows cols columns"><![CDATA[a = array([10,20,30])
maxindex = a.argmax()
a[maxindex]
# 30

a = array([[10,50,30],[60,20,40]])
maxindex = a.argmax()
maxindex
# 3

a.ravel()[maxindex]
# 60

a.argmax(axis=0) # for each column: the row index of the maximum value
# array([1, 0, 1])

a.argmax(axis=1) # for each row: the column index of the maximum value
# array([1, 0])

argmax(a) # also exists, slower, default is axis=-1
# array([1, 0])]]></code>
      <code tags="argmin argument min minimum axis rows cols columns"><![CDATA[a = array([10,20,30])
minindex = a.argmin()
a[minindex]
# 10

a = array([[10,50,30],[60,20,40]])
minindex = a.argmin()
minindex
# 0

a.ravel()[minindex]
# 10

a.argmin(axis=0) # for each column: the row index of the minimum value
# array([0, 1, 0])

a.argmin(axis=1) # for each row: the column index of the minimum value
# array([0, 1])

argmin(a) # also exists, slower, default is axis=-1
# array([0, 1])]]></code>
      <code tags="argsort argument sort quicksort mergesort heapsort stable preserve order indices rows cols columns"><![CDATA[a = array([2,0,8,4,1])
ind = a.argsort() # indices of sorted array using quicksort (default)
ind
# array([1, 4, 0, 3, 2])

a[ind] # same effect as a.sort()
# array([0, 1, 2, 4, 8])

ind = a.argsort(kind='merge') # algorithm options are 'quicksort', 'mergesort' and 'heapsort'
a = array([[8,4,1],[2,0,9]])
ind = a.argsort(axis=0) # sorts on columns. NOT the same as a.sort(axis=1)
ind
# array([[1, 1, 0],
#        [0, 0, 1]])

a[ind,[[0,1,2],[0,1,2]]] # 2-D arrays need fancy indexing if you want to sort them.
# array([[2, 0, 1],
#        [8, 4, 9]])

ind = a.argsort(axis=1) # sort along rows. Can use a.argsort(axis=-1) for last axis.
ind
# array([[2, 1, 0],
#        [1, 0, 2]])

a = ones(17)
a.argsort() # quicksort doesn't preserve original order.
# array([ 0, 14, 13, 12, 11, 10, 9, 15, 8, 6, 5, 4, 3, 2, 1, 7, 16])

a.argsort(kind="mergesort") # mergesort preserves order when possible. It is a stable sort.
# array([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16])

ind = argsort(a) # there is a functional form]]></code>
      <code tags="array type dtype nested descriptor recarray"><![CDATA[array([1,2,3]) # conversion from a list to an array
# array([1, 2, 3])

array([1,2,3], dtype=complex) # output type is specified
# array([ 1.+0.j, 2.+0.j, 3.+0.j])

array(1, copy=0, subok=1, ndmin=1) # basically equivalent to atleast_1d
# array([1])

array(1, copy=0, subok=1, ndmin=2) # basically equivalent to atleast_2d
# array([[1]])

array(1, subok=1, ndmin=2) # like atleast_2d but always makes a copy
# array([[1]])

mydescriptor = {'names': ('gender','age','weight'), 'formats': ('S1', 'f4', 'f4')} # one way of specifying the data type
a = array([('M',64.0,75.0),('F',25.0,60.0)], dtype=mydescriptor) # recarray
print a
# [('M', 64.0, 75.0) ('F', 25.0, 60.0)]

a['weight']
# array([ 75., 60.], dtype=float32)

a.dtype.names # Access to the ordered field names
# ('gender','age','weight')

mydescriptor = [('age',int16),('Nchildren',int8),('weight',float32)] # another way of specifying the data type
a = array([(64,2,75.0),(25,0,60.0)], dtype=mydescriptor)
a['Nchildren']
# array([2, 0], dtype=int8)

mydescriptor = dtype([('x', 'f4'),('y', 'f4'), # nested recarray
('nested', [('i', 'i2'),('j','i2')])])
array([(1.0, 2.0, (1,2))], dtype=mydescriptor) # input one row
# array([(1.0, 2.0, (1, 2))],
#       dtype=[('x', '<f4'), ('y', '<f4'), ('nested', [('i', '<i2'), ('j', '<i2')])])

array([(1.0, 2.0, (1,2)), (2.1, 3.2, (3,2))], dtype=mydescriptor) # input two rows
# array([(1.0, 2.0, (1, 2)), (2.0999999046325684, 3.2000000476837158, (3, 2))],
#       dtype=[('x', '<f4'), ('y', '<f4'), ('nested', [('i', '<i2'), ('j', '<i2')])])

a=array([(1.0, 2.0, (1,2)), (2.1, 3.2, (3,2))], dtype=mydescriptor) # getting some columns
a['x'] # a plain column
# array([ 1. , 2.0999999], dtype=float32)

a['nested'] # a nested column
# array([(1, 2), (3, 2)],
#       dtype=[('i', '<i2'), ('j', '<i2')])

a['nested']['i'] # a plain column inside a nested column
mydescriptor = dtype([('x', 'f4'),('y', 'f4'), # nested recarray
('nested', [('i', 'i2'),('j','i2')])])
array([(1.0, 2.0, (1,2))], dtype=mydescriptor) # input one row
# array([(1.0, 2.0, (1, 2))],
#       dtype=[('x', '<f4'), ('y', '<f4'), ('nested', [('i', '<i2'), ('j', '<i2')])])

array([(1.0, 2.0, (1,2)), (2.1, 3.2, (3,2))], dtype=mydescriptor) # input two rows
# array([(1.0, 2.0, (1, 2)), (2.0999999046325684, 3.2000000476837158, (3, 2))],
#       dtype=[('x', '<f4'), ('y', '<f4'), ('nested', [('i', '<i2'), ('j', '<i2')])])

a=array([(1.0, 2.0, (1,2)), (2.1, 3.2, (3,2))], dtype=mydescriptor) # getting some columns
a['x'] # a plain column
# array([ 1. , 2.0999999], dtype=float32)

a['nested'] # a nested column
# array([(1, 2), (3, 2)],
#       dtype=[('i', '<i2'), ('j', '<i2')])

a['nested']['i'] # a plain column inside a nested column
# array([1, 3], dtype=int16)]]></code>
      <code tags="array_split split parts"><![CDATA[a = array([[1,2,3,4],[5,6,7,8]])
array_split(a,2,axis=0) # split a in 2 parts. row-wise
# [array([[1, 2, 3, 4]]), array([[5, 6, 7, 8]])]

array_split(a,4,axis=1) # split a in 4 parts, column-wise
# [array([[1],
#         [5]]),
#  array([[2],
#         [6]]),
#  array([[3],
#         [7]]),
#  array([[4],
#         [8]])]

array_split(a,3,axis=1) # impossible to split in 3 equal parts -> first part(s) are bigger
# [array([[1, 2],
#         [5, 6]]),
#  array([[3],
#         [7]]),
#  array([[4],
#         [8]])]

array_split(a,[2,3],axis=1) # make a split before the 2nd and the 3rd column
# [array([[1, 2],
#         [5, 6]]),
#  array([[3],
#         [7]]),
#  array([[4],
#         [8]])]]]></code>
      <code tags="asarray as array matrix"><![CDATA[m = matrix('1 2; 5 8')
m
# matrix([[1, 2],
#         [5, 8]])

a = asarray(m) # a is array type with same contents as m -- data is not copied
a
# array([[1, 2],
#        [5, 8]])

m[0,0] = -99
m
# matrix([[-99, 2],
#         [ 5, 8]])

a # no copy was made, so modifying m modifies a, and vice versa
# array([[-99, 2],
#        [ 5, 8]])]]></code>
      <code tags="asanyarray as any array"><![CDATA[a = array([[1,2],[5,8]])
a
# array([[1, 2],
#        [5, 8]])

m = matrix('1 2; 5 8')
m
# matrix([[1, 2],
#         [5, 8]])

asanyarray(a) # the array a is returned unmodified
# array([[1, 2],
#        [5, 8]])

asanyarray(m) # the matrix m is returned unmodified
# matrix([[1, 2],
#         [5, 8]])

asanyarray([1,2,3]) # a new array is constructed from the list
# array([1, 2, 3])]]></code>
      <code tags="asmatrix as matrix"><![CDATA[a = array([[1,2],[5,8]])
a
# array([[1, 2],
#        [5, 8]])

m = asmatrix(a) # m is matrix type with same contents as a -- data is not copied
m
# matrix([[1, 2],
#         [5, 8]])

a[0,0] = -99
a
# array([[-99, 2],
#        [ 5, 8]])

m # no copy was made so modifying a modifies m, and vice versa
# matrix([[-99, 2],
#         [ 5, 8]])]]></code>
      <code tags="astype as type convert int float"><![CDATA[x = array([1,2,3])
y = x.astype(float64) # convert from int32 to float64
type(y[0])
# <type 'numpy.float64'>

x.astype(None) # None implies converting to the default (float64)
# array([1., 2., 3.])]]></code>
      <code tags="atleast_1d at least 1d dim dimension"><![CDATA[a = 1 # 0-d array
b = array([2,3]) # 1-d array
c = array([[4,5],[6,7]]) # 2-d array
d = arange(8).reshape(2,2,2) # 3-d array
d
# array([[[0, 1],
#         [2, 3]],
#        [[4, 5],
#         [6, 7]]])

atleast_1d(a,b,c,d) # all output arrays have dim >= 1
# [array([1]),
#  array([2, 3]),
#  array([[4, 5],
#         [6, 7]]),
#  array([[[0, 1],
#          [2, 3]],
#         [[4, 5],
#          [6, 7]]])]]]></code>
      <code tags="atleast_2d at least 2d dim dimension"><![CDATA[a = 1 # 0-d array
b = array([2,3]) # 1-d array
c = array([[4,5],[6,7]]) # 2-d array
d = arange(8).reshape(2,2,2) # 3-d array
d
# array([[[0, 1],
#         [2, 3]],
#        [[4, 5],
#         [6, 7]]])

atleast_2d(a,b,c,d) # all output arrays have dim >= 2
# [array([[1]]),
#  array([[2, 3]]),
#  array([[4, 5],
#         [6, 7]]),
#  array([[[0, 1],
#          [2, 3]],
#         [[4, 5],
#          [6, 7]]])]]]></code>
      <code tags="atleast_3d at least 3d dim dimension"><![CDATA[a = 1 # 0-d array
b = array([2,3]) # 1-d array
c = array([[4,5],[6,7]]) # 2-d array
d = arange(8).reshape(2,2,2) # 3-d array
d
# array([[[0, 1],
#         [2, 3]],
#        [[4, 5],
#         [6, 7]]])

atleast_3d(a,b,c,d) # all output arrays have dim >= 3
# [array([[[1]]]),
#  array([[[2],
#          [3]]]),
#  array([[[4],
#          [5]],
#         [[6],
#          [7]]]),
#  array([[[0, 1],
#          [2, 3]],
#         [[4, 5],
#          [6, 7]]])]]]></code>
      <code tags="avg average mean weights weighted"><![CDATA[a = array([1,2,3,4,5])
w = array([0.1, 0.2, 0.5, 0.2, 0.2]) # weights, not necessarily normalized
average(a) # plain mean value
# 3.0

average(a,weights=w) # weighted average
# 3.1666666666666665

average(a,weights=w,returned=True) # output = weighted average, sum of weights
# (3.1666666666666665, 1.2)]]></code>
      <code tags="beta distribution"><![CDATA[beta(a=1,b=10,size=(2,2)) # Beta distribution alpha=1, beta=10
# array([[ 0.02571091, 0.04973536],
#        [ 0.04887027, 0.02382052]])]]></code>
      <code tags="binary_repr binary representation bitstring"><![CDATA[a = 25
binary_repr(a) # binary representation of 25
# '11001'

b = float_(pi) # numpy float has extra functionality ...
b.nbytes # ... like the number of bytes it takes
# 8

binary_repr(b.view('u8')) # view float number as an 8 byte integer, then get binary bitstring
# '1010100010001000010110100011000']]></code>
      <code tags="bincount bin count"><![CDATA[a = array([1,1,1,1,2,2,4,4,5,6,6,6]) # doesn't need to be sorted
bincount(a) # 0 occurs 0 times, 1 occurs 4 times, 2 occurs twice, 3 occurs 0 times, ...
# array([0, 4, 2, 0, 2, 1, 3])

a = array([5,4,4,2,2])
w = array([0.1, 0.2, 0.1, 0.3, 0.5])
bincount(a) # 0 & 1 don't occur, 2 occurs twice, 3 doesn't occur, 4 occurs twice, 5 once
# array([0, 0, 2, 0, 2, 1])

bincount(a, weights=w)
# array([ 0. , 0. , 0.8, 0. , 0.3, 0.1])
# 0 occurs 0 times -> result[0] = 0
# 1 occurs 0 times -> result[1] = 0
# 2 occurs at indices 3 & 4 -> result[2] = w[3] + w[4]
# 3 occurs 0 times -> result[3] = 0
# 4 occurs at indices 1 & 2 -> result[4] = w[1] + w[2]
# 5 occurs at index 0 -> result[5] = w[0]]]></code>
      <code tags="binomial distribution"><![CDATA[binomial(n=100,p=0.5,size=(2,3)) # binomial distribution n trials, p = success probability
# array([[38, 50, 53],
#        [56, 48, 54]])

from pylab import * # histogram plot example
hist(binomial(100,0.5,(1000)), 20)]]></code>
      <code tags="bitwise_and bitwise and"><![CDATA[bitwise_and(array([2,5,255]), array([4,4,4]))
# array([0, 4, 4])

bitwise_and(array([2,5,255,2147483647L],dtype=int32), array([4,4,4,2147483647L],dtype=int32))
# array([ 0, 4, 4, 2147483647])]]></code>
      <code tags="bitwise_or bitwise or"><![CDATA[bitwise_or(array([2,5,255]), array([4,4,4]))
# array([ 6, 5, 255])

bitwise_or(array([2,5,255,2147483647L],dtype=int32), array([4,4,4,2147483647L],dtype=int32))
# array([ 6, 5, 255, 2147483647])]]></code>
      <code tags="bitwise_xor bitwise xor"><![CDATA[bitwise_xor(array([2,5,255]), array([4,4,4]))
# array([ 6, 1, 251])

bitwise_xor(array([2,5,255,2147483647L],dtype=int32), array([4,4,4,2147483647L],dtype=int32))
# array([ 6, 1, 251, 0])]]></code>
      <code tags="bmat build matrix"><![CDATA[a = mat('1 2; 3 4')
b = mat('5 6; 7 8')
bmat('a b; b a') # all elements must be existing symbols
# matrix([[1, 2, 5, 6],
#         [3, 4, 7, 8],
#         [5, 6, 1, 2],
#         [7, 8, 3, 4]])]]></code>
      <code tags="broadcast"><![CDATA[a = array([[1,2],[3,4]])
b = array([5,6])
c = broadcast(a,b)
c.nd # the number of dimensions in the broadcasted result
# 2

c.shape # the shape of the broadcasted result
# (2, 2)

c.size # total size of the broadcasted result
# 4
for value in c: print value
# (1, 5)
# (2, 6)
# (3, 5)
# (4, 6)

c.reset() # reset the iterator to the beginning
c.next() # next element
# (1, 5)]]></code>
      <code tags="bytes string"><![CDATA[from numpy.random import bytes
print repr(bytes(5)) # string of 5 random bytes
# 'o\x07\x9f\xdf\xdf'

print repr(bytes(5)) # another string of 5 random bytes
# '\x98\xc9KD\xe0']]></code>
      <code tags="c_ single stack column wise concat concatenate concatenation along 1s last axis"><![CDATA[c_[1:5] # for single ranges, c_ works like r_
# array([1, 2, 3, 4])

c_[1:5,2:6] # for comma separated values, c_ stacks column-wise
# array([[1, 2],
#        [2, 3],
#        [3, 4],
#        [4, 5]])

a = array([[1,2,3],[4,5,6]])
c_[a,a] # concatenation along last (default) axis (column-wise, that's why it's called c_)
# array([[1, 2, 3, 1, 2, 3],
#        [4, 5, 6, 4, 5, 6]])

c_['0',a,a] # concatenation along 1st axis, equivalent to r_[a,a]
# array([[1, 2, 3],
#        [4, 5, 6],
#        [1, 2, 3],
#        [4, 5, 6]])]]></code>
      <code tags="cast int uint float dtype type"><![CDATA[x = arange(3)
x.dtype
# dtype('int32')

cast['int64'](x)
# array([0, 1, 2], dtype=int64)

cast['uint'](x)
# array([0, 1, 2], dtype=uint32)

cast[float64](x)
# array([0.0, 1.0, 2.0], dtype=float64)

cast.keys() # list dtype cast possibilities
# [numpy.complex128,
#  numpy.void,
#  numpy.int64,
#  numpy.uint64,
#  numpy.bool_,
#  numpy.int8,
#  numpy.uint8,
#  numpy.float16,
#  numpy.timedelta64,
#  numpy.object_,
#  numpy.int16,
#  numpy.uint16,
#  numpy.float32,
#  numpy.complex64,
#  numpy.string_,
#  numpy.int32,
#  numpy.uint32,
#  numpy.float64,
#  numpy.complex128,
#  numpy.datetime64,
#  numpy.unicode_,
#  numpy.int32,
#  numpy.uint32,
#  numpy.float64]]]></code>
      <code tags="ceil nearest integer greater or equal"><![CDATA[a = array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7])
ceil(a) # nearest integers greater-than or equal to a
# array([-1., -1., -0., 1., 2., 2.])]]></code>
      <code tags="choose choice select selector"><![CDATA[choice0 = array([10,12,14,16]) # selector and choice arrays must be equally sized
choice1 = array([20,22,24,26])
choice2 = array([30,32,34,36])
selector = array([0,0,2,1]) # selector can only contain integers in range(number_of_choice_arrays)
selector.choose(choice0,choice1,choice2)
# array([10, 12, 34, 26])

a = arange(4)
choose(a >= 2, (choice0, choice1)) # separate function also exists
# array([10, 12, 24, 26])]]></code>
      <code tags="clip bound"><![CDATA[a = array([5,15,25,3,13])
a.clip(min=10,max=20)
# array([10, 15, 20, 10, 13])

clip(a,10,20) # this syntax also exists]]></code>
      <code tags="column_stack column stack c_"><![CDATA[a = array([1,2])
b = array([3,4])
c = array([5,6])
column_stack((a,b,c)) # a,b,c are 1-d arrays with equal length
# array([[1, 3, 5],
#        [2, 4, 6]])]]></code>
      <code tags="compress filter select choose take where"><![CDATA[a = array([10, 20, 30, 40])
condition = (a > 15) & (a < 35)
condition
# array([False, True, True, False], dtype=bool)

a.compress(condition)
# array([20, 30])

a[condition] # same effect
# array([20, 30])

compress(a >= 30, a) # this form also exists
# array([30, 40])

b = array([[10,20,30],[40,50,60]])
b.compress(b.ravel() >= 22)
# array([30, 40, 50, 60])

x = array([3,1,2])
y = array([50, 101])
b.compress(x >= 2, axis=1) # illustrates the use of the axis keyword
# array([[10, 30],
#        [40, 60]])

b.compress(y >= 100, axis=0)
# array([[40, 50, 60]])]]></code>
      <code tags="concatenate"><![CDATA[x = array([[1,2],[3,4]])
y = array([[5,6],[7,8]])
concatenate((x,y)) # default is axis=0
# array([[1, 2],
#        [3, 4],
#        [5, 6],
#        [7, 8]])

concatenate((x,y),axis=1)
# array([[1, 2, 5, 6],
#        [3, 4, 7, 8]])]]></code>
      <code tags="conj conjugate"><![CDATA[a = array([1+2j,3-4j])
a.conj() # .conj() and .conjugate() are the same
# array([ 1.-2.j, 3.+4.j])

a.conjugate()
# array([ 1.-2.j, 3.+4.j])

conj(a) # is also possible
conjugate(a) # is also possible]]></code>
      <code tags="copy ref reference"><![CDATA[a = array([1,2,3])
a
# array([1, 2, 3])

b = a # b is a reference to a
b[1] = 4
a
# array([1, 4, 3])

a = array([1,2,3])
b = a.copy() # b is now an independent copy of a
b[1] = 4
a
# array([1, 2, 3])

b
# array([1, 4, 3])]]></code>
      <code tags="corrcoef correlation"><![CDATA[T = array([1.3, 4.5, 2.8, 3.9]) # temperature measurements
P = array([2.7, 8.7, 4.7, 8.2]) # corresponding pressure measurements
print corrcoef([T,P]) # correlation matrix of temperature and pressure
# [[ 1. 0.98062258]
#  [ 0.98062258 1. ]]

rho = array([8.5, 5.2, 6.9, 6.5]) # corresponding density measurements
data = column_stack([T,P,rho])
print corrcoef([T,P,rho]) # correlation matrix of T,P and rho
# [[ 1. 0.98062258 -0.97090288]
#  [ 0.98062258 1. -0.91538464]
#  [-0.97090288 -0.91538464 1. ]]]]></code>
      <code tags="cos cosine"><![CDATA[cos(array([0, pi/2, pi]))
# array([ 1.00000000e+00, 6.12303177e-17, -1.00000000e+00])]]></code>
      <code tags="cov covariance variance bias"><![CDATA[x = array([1., 3., 8., 9.])
variance = cov(x) # normalized by N-1
variance = cov(x, bias=1) # normalized by N
T = array([1.3, 4.5, 2.8, 3.9]) # temperature measurements
P = array([2.7, 8.7, 4.7, 8.2]) # corresponding pressure measurements
cov(T,P) # covariance between temperature and pressure
# 3.9541666666666657

rho = array([8.5, 5.2, 6.9, 6.5]) # corresponding density measurements
data = column_stack([T,P,rho])
print cov(data) # covariance matrix of T,P and rho
# [[ 1.97583333 3.95416667 -1.85583333]
#  [ 3.95416667 8.22916667 -3.57083333]
#  [-1.85583333 -3.57083333 1.84916667]]]]></code>
      <code tags="vector cross product"><![CDATA[x = array([1,2,3])
y = array([4,5,6])
cross(x,y) # vector cross-product
# array([-3, 6, -3])]]></code>
      <code tags="cumprod cummulative product mul multiplication axis rows cols columns"><![CDATA[a = array([1,2,3])
a.cumprod() # total product 1*2*3 = 6, and intermediate results 1, 1*2
# array([1, 2, 6])

cumprod(a) # also exists
# array([1, 2, 6])

a = array([[1,2,3],[4,5,6]])
a.cumprod(dtype=float) # specify type of output
# array([1., 2., 6., 24., 120., 720.])

a.cumprod(axis=0) # for each of the 3 columns: product and intermediate results
# array([[ 1, 2, 3],
#        [ 4, 10, 18]])

a.cumprod(axis=1) # for each of the two rows: product and intermediate results
# array([[ 1, 2, 6],
#        [ 4, 20, 120]])]]></code>
      <code tags="cumsum cummulative sum add addition axis rows cols columns"><![CDATA[a = array([1,2,3]) # cumulative sum = intermediate summing results & total sum
a.cumsum()
# array([1, 3, 6])

cumsum(a) # also exists
# array([1, 3, 6])

a = array([[1,2,3],[4,5,6]])
a.cumsum(dtype=float) # specifies type of output value(s)
# array([ 1., 3., 6., 10., 15., 21.])

a.cumsum(axis=0) # sum over rows for each of the 3 columns
# array([[1, 2, 3],
#        [5, 7, 9]])

a.cumsum(axis=1) # sum over columns for each of the 2 rows
# array([[ 1, 3, 6],
#        [ 4, 9, 15]])]]></code>
      <code tags="delete remove axis rows cols columns"><![CDATA[a = array([0, 10, 20, 30, 40])
delete(a, [2,4]) # remove a[2] and a[4]
# array([ 0, 10, 30])

a = arange(16).reshape(4,4)
a
# array([[ 0, 1, 2, 3],
#        [ 4, 5, 6, 7],
#        [ 8, 9, 10, 11],
#        [12, 13, 14, 15]])

delete(a, s_[1:3], axis=0) # remove rows 1 and 2
# array([[ 0, 1, 2, 3],
#        [12, 13, 14, 15]])

delete(a, s_[1:3], axis=1) # remove columns 1 and 2
# array([[ 0, 3],
#        [ 4, 7],
#        [ 8, 11],
#        [12, 15]])]]></code>
      <code tags="det determinant linalg linear algebra"><![CDATA[from numpy.linalg import det
A = array([[1., 2.],[3., 4.]])
det(A) # determinant of square matrix
# -2.0]]></code>
      <code tags="diag diagonal matrix"><![CDATA[a = arange(12).reshape(4,3)
print a
# [[ 0 1 2]
#  [ 3 4 5]
#  [ 6 7 8]
#  [ 9 10 11]]

print diag(a,k=0)
# [0 4 8]

print diag(a,k=1)
# [1 5]

print diag(array([1,4,5]),k=0)
# [[1 0 0]
#  [0 4 0]
#  [0 0 5]]

print diag(array([1,4,5]),k=1)
# [[0 1 0 0]
#  [0 0 4 0]
#  [0 0 0 5]
#  [0 0 0 0]]]]></code>
      <code tags="diagflat diag diagonal flatten matrix"><![CDATA[x = array([[5,6],[7,8]])
diagflat(x) # flatten x, then put elements on diagonal
# array([[5, 0, 0, 0],
#        [0, 6, 0, 0],
#        [0, 0, 7, 0],
#        [0, 0, 0, 8]])]]></code>
      <code tags="diagonal diag offset"><![CDATA[a = arange(12).reshape(3,4)
print a
# [[ 0 1 2 3]
#  [ 4 5 6 7]
#  [ 8 9 10 11]]

a.diagonal()
# array([ 0, 5, 10])

a.diagonal(offset=1)
# array([ 1, 6, 11])

diagonal(a) # Also this form exists
# array([ 0, 5, 10])]]></code>
      <code tags="diff differences 1st order discrete derivation axis rows cols columns"><![CDATA[x = array([0,1,3,9,5,10])
diff(x) # 1st-order differences between the elements of x
# array([ 1, 2, 6, -4, 5])

diff(x,n=2) # 2nd-order differences, equivalent to diff(diff(x))
# array([ 1, 4, -10, 9])

x = array([[1,3,6,10],[0,5,6,8]])
diff(x) # 1st-order differences between the columns (default: axis=-1)
# array([[2, 3, 4],
#        [5, 1, 2]])

diff(x,axis=0) # 1st-order difference between the rows
# array([[-1, 2, 0, -2]])]]></code>
      <code tags="digitize digit bin histogram"><![CDATA[x = array([0.2, 6.4, 3.0, 1.6])
bins = array([0.0, 1.0, 2.5, 4.0, 10.0]) # monotonically increasing
d = digitize(x,bins) # in which bin falls each value of x?
d
# array([1, 4, 3, 2])

for n in range(len(x)):
  print bins[d[n]-1], "<=", x[n], "<", bins[d[n]]
# 0.0 <= 0.2 < 1.0
# 4.0 <= 6.4 < 10.0
# 2.5 <= 3.0 < 4.0
# 1.0 <= 1.6 < 2.5]]></code>
      <code tags="dot matrix mul multiplication blas lapack"><![CDATA[x = array([[1,2,3],[4,5,6]])
x.shape
# (2, 3)

y = array([[1,2],[3,4],[5,6]])
y.shape
# (3, 2)

dot(x,y) # matrix multiplication (2,3) x (3,2) -> (2,2)
# array([[22, 28],
#        [49, 64]])

import numpy
if id(dot) == id(numpy.core.multiarray.dot): # A way to know if you use fast blas/lapack or not.
  print "Not using blas/lapack!"]]></code>
      <code tags="dsplit split dstack stack depth wise"><![CDATA[a = array([[1,2],[3,4]])
b = dstack((a,a,a,a))
b.shape # stacking in depth: for k in (0,..,3): b[:,:,k] = a
# (2, 2, 4)

c = dsplit(b,2) # split, depth-wise, in 2 equal parts
print c[0].shape, c[1].shape # for k in (0,1): c[0][:,:,k] = a and c[1][:,:,k] = a
# (2, 2, 2) (2, 2, 2)

d = dsplit(b,[1,2]) # split before [:,:,1] and before [:,:,2]
print d[0].shape, d[1].shape, d[2].shape # for any of the parts: d[.][:,:,k] = a
# (2, 2, 1) (2, 2, 1) (2, 2, 2)]]></code>
      <code tags="dstack stack depth wise third axis"><![CDATA[a = array([[1,2],[3,4]]) # shapes of a and b can only differ in the 3rd dimension (if present)
b = array([[5,6],[7,8]])
dstack((a,b)) # stack arrays along a third axis (depth wise)
# array([[[1, 5],
#         [2, 6]],
#        [[3, 7],
#         [4, 8]]])]]></code>
      <code tags="dtype type int uint unsigned integer string kind char code num typestring byte order byteorder item size itemsize fields access nested"><![CDATA[dtype('int16') # using array-scalar type
# dtype('int16')

dtype([('f1', 'int16')]) # record, 1 field named 'f1', containing int16
# dtype([('f1', '<i2')])

dtype([('f1', [('f1', 'int16')])]) # record, 1 field named 'f1' containing a record that has 1 field.
# dtype([('f1', [('f1', '<i2')])])

dtype([('f1', 'uint'), ('f2', 'int32')]) # record with 2 fields: field 1 contains an unsigned int, 2nd field an int32
# dtype([('f1', '<u4'), ('f2', '<i4')])

dtype([('a','f8'),('b','S10')]) # using array-protocol type strings
# dtype([('a', '<f8'), ('b', '|S10')])

dtype("i4, (2,3)f8") # using comma-separated field formats. (2,3) is the shape
# dtype([('f0', '<i4'), ('f1', '<f8', (2, 3))])

dtype([('hello',('int',3)),('world','void',10)]) # using tuples. int is fixed-type: 3 is shape; void is flex-type: 10 is size.
# dtype([('hello', '<i4', 3), ('world', '|V10')])

dtype(('int16', {'x':('int8',0), 'y':('int8',1)})) # subdivide int16 in 2 int8, called x and y. 0 and 1 are the offsets in bytes
# dtype(('<i2', [('x', '|i1'), ('y', '|i1')]))

dtype({'names':['gender','age'], 'formats':['S1',uint8]}) # using dictionaries. 2 fields named 'gender' and 'age'
# dtype([('gender', '|S1'), ('age', '|u1')])

dtype({'surname':('S25',0),'age':(uint8,25)}) # 0 and 25 are offsets in bytes
# dtype([('surname', '|S25'), ('age', '|u1')])

a = dtype('int32')
a
# dtype('int32')

a.type # type object
# <type 'numpy.int32'>

a.kind # character code (one of 'biufcSUV') to identify general type
# 'i'

a.char # unique char code of each of the 21 built-in types
# 'l'

a.num # unique number of each of the 21 built-in types
# 7

a.str # array-protocol typestring
# '<i4'

a.name # name of this datatype
# 'int32'

a.byteorder # '=':native, '<':little endian, '>':big endian, '|':not applicable
# '='

a.itemsize # item size in bytes
# 4

a = dtype({'surname':('S25',0),'age':(uint8,25)})
a.fields.keys()
# ['age', 'surname']

a.fields.values()
# [(dtype('uint8'), 25), (dtype('|S25'), 0)]

a = dtype([('x', 'f4'),('y', 'f4'), # nested field
('nested', [('i', 'i2'),('j','i2')])])
a.fields['nested'] # access nested fields
# (dtype([('i', '<i2'), ('j', '<i2')]), 8)

a.fields['nested'][0].fields['i'] # access nested fields
# (dtype('int16'), 0)

a.fields['nested'][0].fields['i'][0].type
# <type 'numpy.int16'>]]></code>
      <code tags="empty uninitialized array"><![CDATA[empty(3) # uninitialized array, size=3, dtype = float
# array([ 6.08581638e+000, 3.45845952e-323, 4.94065646e-324])

empty((2,3),int) # uninitialized array, dtype = int
# array([[1075337192, 1075337192, 135609024],
#        [1084062604, 1197436517, 1129066306]])]]></code>
      <code tags="empty_like empty like uninitialized array same shape data type dtype"><![CDATA[a = array([[1,2,3],[4,5,6]])
empty_like(a) # uninitialized array with the same shape and datatype as 'a'
# array([[ 0, 25362433, 6571520],
#        [ 21248, 136447968, 4]])]]></code>
      <code tags="expand_dims expand dims dimensions add new axis newaxis extend"><![CDATA[x = array([1,2])
expand_dims(x,axis=0) # Equivalent to x[newaxis,:] or x[None] or x[newaxis]
# array([[1, 2]])

expand_dims(x,axis=1) # Equivalent to x[:,newaxis]
# array([[1],
#        [2]])]]></code>
      <code tags="eye identity matrix diagonal ones"><![CDATA[eye(3,4,0,dtype=float) # a 3x4 matrix containing zeros except for the 0th diagonal that contains ones
# array([[ 1., 0., 0., 0.],
#        [ 0., 1., 0., 0.],
#        [ 0., 0., 1., 0.]])

eye(3,4,1,dtype=float) # a 3x4 matrix containing zeros except for the 1st diagonal that contains ones
# array([[ 0., 1., 0., 0.],
#        [ 0., 0., 1., 0.],
#        [ 0., 0., 0., 1.]])]]></code>
      <code tags="fft fftfreq fast fourier transformation signal freq"><![CDATA[from numpy.fft import *
signal = array([-2., 8., -6., 4., 1., 0., 3., 5.]) # could also be complex
fourier = fft(signal)
fourier
# array([ 13. +0.j , 3.36396103 +4.05025253j,
#          2. +1.j , -9.36396103-13.94974747j,
#        -21. +0.j , -9.36396103+13.94974747j,
#          2. -1.j , 3.36396103 -4.05025253j])

N = len(signal)
fourier = empty(N,complex)
for k in range(N): # equivalent but much slower
fourier[k] = sum(signal * exp(-1j*2*pi*k*arange(N)/N))

timestep = 0.1 # if unit=day -> freq unit=cycles/day
fftfreq(N, d=timestep) # freqs corresponding to 'fourier'
# array([ 0. , 1.25, 2.5 , 3.75, -5. , -3.75, -2.5 , -1.25])]]></code>
      <code tags="fftfreq fft fast fourier transformation signal fftshift shift ascending order"><![CDATA[from numpy.fft import *
signal = array([-2., 8., -6., 4., 1., 0., 3., 5.])
fourier = fft(signal)
N = len(signal)
timestep = 0.1 # if unit=day -> freq unit=cycles/day
freq = fftfreq(N, d=timestep) # freqs corresponding to 'fourier'
freq
# array([ 0. , 1.25, 2.5 , 3.75, -5. , -3.75, -2.5 , -1.25])

fftshift(freq) # freqs in ascending order
# array([-5. , -3.75, -2.5 , -1.25, 0. , 1.25, 2.5 , 3.75])]]></code>
      <code tags="fftshift inverse ifftshift fftfreq fft fast fourier transformation signal shift ascending order"><![CDATA[from numpy.fft import *
signal = array([-2., 8., -6., 4., 1., 0., 3., 5.])
fourier = fft(signal)
N = len(signal)
timestep = 0.1 # if unit=day -> freq unit=cycles/day
freq = fftfreq(N, d=timestep) # freqs corresponding to 'fourier'
freq
# array([ 0. , 1.25, 2.5 , 3.75, -5. , -3.75, -2.5 , -1.25])

freq = fftshift(freq) # freqs in ascending order
freq
# array([-5. , -3.75, -2.5 , -1.25, 0. , 1.25, 2.5 , 3.75])

fourier = fftshift(fourier) # adjust fourier to new freq order
freq = ifftshift(freq) # undo previous frequency shift
fourier = ifftshift(fourier) # undo previous fourier shift]]></code>
      <code tags="fill all elements"><![CDATA[a = arange(4, dtype=int)
a
# array([0, 1, 2, 3])

a.fill(7) # replace all elements with the number 7
a
# array([7, 7, 7, 7])

a.fill(6.5) # fill value is converted to dtype of a
a
# array([6, 6, 6, 6])]]></code>
      <code tags="finfo float machep eps precision resolution negep epsneg minexp tiny maxexp min max"><![CDATA[f = finfo(float) # the numbers given are machine dependent
f.nmant, f.nexp # nr of bits in the mantissa and in the exponent
# (52, 11)

f.machep # most negative n so that 1.0 + 2**n != 1.0
# -52

f.eps # floating point precision: 2**machep
# array(2.2204460492503131e-16)

f.precision # nr of precise decimal digits: int(-log10(eps))
# 15

f.resolution # 10**(-precision)
# array(1.0000000000000001e-15)

f.negep # most negative n so that 1.0 - 2**n != 1.0
# -53

f.epsneg # floating point precision: 2**negep
# array(1.1102230246251565e-16)

f.minexp # most negative n so that 2**n gives normal numbers
# -1022

f.tiny # smallest usuable floating point nr: 2**minexp
# array(2.2250738585072014e-308)

f.maxexp # smallest positive n so that 2**n causes overflow
# 1024

f.min, f.max # the most negative and most positive usuable floating number
# (-1.7976931348623157e+308, array(1.7976931348623157e+308))]]></code>
      <code tags="fix round integer"><![CDATA[a = array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7])
fix(a) # round a to nearest integer towards zero
# array([-1., -1., 0., 0., 1., 1.])]]></code>
      <code tags="flat iterator cycle next"><![CDATA[a = array([[10,30],[40,60]])
iter = a.flat # .flat returns an iterator
iter.next() # cycle through array with .next()
# 10

iter.next()
# 30

iter.next()
# 40]]></code>
      <code tags="flatten flat 1d one dim dimension"><![CDATA[a = array([[[1,2]],[[3,4]]])
print a
# [[[1 2]]
#  [[3 4]]]

b = a.flatten() # b is now a 1-d version of a, a new array, not a reference
print b
# [1 2 3 4]]]></code>
      <code tags="fliplr flip left right swap mirror"><![CDATA[a = arange(12).reshape(4,3)
a
# array([[ 0, 1, 2],
#        [ 3, 4, 5],
#        [ 6, 7, 8],
#        [ 9, 10, 11]])

fliplr(a) # flip left-right
# array([[ 2, 1, 0],
#        [ 5, 4, 3],
#        [ 8, 7, 6],
#        [11, 10, 9]])]]></code>
      <code tags="flipud flip up down swap mirror"><![CDATA[a = arange(12).reshape(4,3)
a
# array([[ 0, 1, 2],
#        [ 3, 4, 5],
#        [ 6, 7, 8],
#        [ 9, 10, 11]])

flipud(a) # flip up-down
# array([[ 9, 10, 11],
#        [ 6, 7, 8],
#        [ 3, 4, 5],
#        [ 0, 1, 2]])]]></code>
      <code tags="floor nearest integer smaller or equal round"><![CDATA[a = array([-1.7, -1.5, -0.2, 0.2, 1.5, 1.7])
floor(a)
# array([-2., -2., -1., 0., 1., 1.]) # nearest integer smaller-than or equal to a]]></code>
      <code tags="fromarrays from arrays"><![CDATA[x = array(['Smith','Johnson','McDonald']) # datatype is string
y = array(['F','F','M'], dtype='S1') # datatype is a single character
z = array([20,25,23]) # datatype is integer
data = rec.fromarrays([x,y,z], names='surname, gender, age') # convert to record array
data[0]
# ('Smith', 'F', 20)

data.age # names are available as attributes
# array([20, 25, 23])]]></code>
      <code tags="frombuffer from buffer"><![CDATA[buffer = "\x00\x00\x00\x00\x00\x00\xf0?\x00\x00\x00\x00\x00\x00\x00@\x00\x00\x00\x00\x00\x00\x08\
@\x00\x00\x00\x00\x00\x00\x10@\x00\x00\x00\x00\x00\x00\x14@\x00\x00\x00\x00\x00\x00\x18@"
a = frombuffer(buffer, complex128)
a
# array([ 1.+2.j, 3.+4.j, 5.+6.j])]]></code>
      <code tags="fromfile from text file csv open load ascii sep separator"><![CDATA[y = array([2.,4.,6.,8.])
y.tofile("myfile.dat") # binary format
y.tofile("myfile.txt", sep='\n', format = "%e") # ascii format, one column, exponential notation
fromfile('myfile.dat', dtype=float)
# array([ 2., 4., 6., 8.])

fromfile('myfile.txt', dtype=float, sep='\n')
# array([ 2., 4., 6., 8.])]]></code>
      <code tags="fromfunction from function"><![CDATA[def f(i,j):
return i**2 + j**2

fromfunction(f, (3,3)) # evaluate functiom for all combinations of indices [0,1,2]x[0,1,2]
# array([[0, 1, 4],
#        [1, 2, 5],
#        [4, 5, 8]])]]></code>
      <code tags="fromiter from iter itertools tools"><![CDATA[import itertools
mydata = [[55.5, 40],[60.5, 70]] # List of lists
mydescriptor = {'names': ('weight','age'), 'formats': (float32, int32)} # Descriptor of the data
myiterator = itertools.imap(tuple,mydata) # Clever way of putting list of lists into iterator
                                          # of tuples. E.g.: myiterator.next() == (55.5, 40.)

a = fromiter(myiterator, dtype = mydescriptor)
a
# array([(55.5, 40), (60.5, 70)],
#       dtype=[('weight', '<f4'), ('age', '<i4')])]]></code>
      <code tags="generic type isinstance is instance scalar"><![CDATA[numpyscalar = string_('7') # Convert to numpy scalar
numpyscalar # Looks like a build-in scalar...
# '7'

type(numpyscalar) # ... but it isn't
# <type 'numpy.string_'>

buildinscalar = '7' # Build-in python scalar
type(buildinscalar)
# <type 'str'>

isinstance(numpyscalar, generic) # Check if scalar is a NumPy one
# True

isinstance(buildinscalar, generic) # Example on how to recognize NumPy scalars
# False]]></code>
      <code tags="gumbel distribution random"><![CDATA[from numpy.random import *
gumbel(loc=0.0,scale=1.0,size=(2,3)) # Gumbel distribution location=0.0, scale=1.0
# array([[-1.25923601, 1.68758144, 1.76620507],
#        [ 1.96820048, -0.21219499, 1.83579566]])

from pylab import * # histogram plot example
hist(gumbel(0,1,(1000)), 50)]]></code>
      <code tags="histogram bins"><![CDATA[x = array([0.2, 6.4, 3.0, 1.6, 0.9, 2.3, 1.6, 5.7, 8.5, 4.0, 12.8])
bins = array([0.0, 1.0, 2.5, 4.0, 10.0]) # increasing monotonically
N,bins = histogram(x,bins)
N,bins
# (array([2, 3, 1, 4]), array([ 0. , 1. , 2.5, 4. , 10. ]))

for n in range(len(bins)-1):
  print "# ", N[n], "number fall into bin [", bins[n], ",", bins[n+1], "["
# # 2 numbers fall into bin [ 0.0 , 1.0 [
# # 3 numbers fall into bin [ 1.0 , 2.5 [
# # 1 numbers fall into bin [ 2.5 , 4.0 [
# # 4 numbers fall into bin [ 4.0 , 10.0 [

N,bins = histogram(x,5,range=(0.0, 10.0)) # 5 bin boundaries in the range (0,10)
N,bins
# (array([4, 2, 2, 1, 2]), array([ 0., 2., 4., 6., 8.]))

N,bins = histogram(x,5,range=(0.0, 10.0), normed=True) # normalize histogram, i.e. divide by len(x)
N,bins
# (array([ 0.18181818, 0.09090909, 0.09090909, 0.04545455, 0.09090909]), array([ 0., 2., 4., 6., 8.]))]]></code>
      <code tags="hsplit split horizontal column wise"><![CDATA[a = array([[1,2,3,4],[5,6,7,8]])
hsplit(a,2) # split, column-wise, in 2 equal parts
# [array([[1, 2],
#         [5, 6]]),
#  array([[3, 4],
#         [7, 8]])]

hsplit(a,[1,2]) # split before column 1 and before column 2
# [array([[1],
#         [5]]),
#  array([[2],
#         [6]]),
#  array([[3, 4],
#         [7, 8]])]]]></code>
      <code tags="hstack stack concatenate horizontal column wise"><![CDATA[a = array([[1],[2]]) # 2x1 array
b = array([[3,4],[5,6]]) # 2x2 array
hstack((a,b,a)) # only the 2nd dimension of the arrays is allowed to be different
# array([[1, 3, 4, 1],
#        [2, 5, 6, 2]])]]></code>
      <code tags="hypot hypotenuse"><![CDATA[hypot(3.,4.) # hypotenuse: sqrt(3**2 + 4**2) = 5
# 5.0

z = array([2+3j, 3+4j])
hypot(z.real, z.imag) # norm of complex numbers
# array([ 3.60555128, 5. ])]]></code>
      <code tags="identity matrix diagonal ones"><![CDATA[identity(3,float)
# array([[ 1., 0., 0.],
#        [ 0., 1., 0.],
#        [ 0., 0., 1.]])]]></code>
      <code tags="ifft inverse fft fast fourier transformation signal"><![CDATA[from numpy.fft import *
signal = array([-2., 8., -6., 4., 1., 0., 3., 5.])
fourier = fft(signal)
ifft(fourier) # Inverse fourier transform
# array([-2. +0.00000000e+00j, 8. +1.51410866e-15j, -6. +3.77475828e-15j,
#         4. +2.06737026e-16j, 1. +0.00000000e+00j, 0. -1.92758271e-15j,
#         3. -3.77475828e-15j, 5. +2.06737026e-16j])

allclose(signal.astype(complex), ifft(fft(signal))) # ifft(fft()) = original signal
# True

N = len(fourier)
signal = empty(N,complex)
for k in range(N): # equivalent but much slower
  signal[k] = sum(fourier * exp(+1j*2*pi*k*arange(N)/N)) / N]]></code>
      <code tags="imag imaginary"><![CDATA[a = array([1+2j,3+4j,5+6j])
a.imag
# array([ 2., 4., 6.])

a.imag = 9
a
# array([ 1.+9.j, 3.+9.j, 5.+9.j])

a.imag = array([9,8,7])
a
# array([ 1.+9.j, 3.+8.j, 5.+7.j])]]></code>
      <code tags="index_exp slice"><![CDATA[myslice = index_exp[2:4,...,4,::-1] # myslice could now be passed to a function, for example.
print myslice
# (slice(2, 4, None), Ellipsis, 4, slice(None, None, -1))]]></code>
      <code tags="indices mesh grid meshgrid"><![CDATA[indices((2,3))
# array([[[0, 0, 0],
#         [1, 1, 1]],
#        [[0, 1, 2],
#         [0, 1, 2]]])

a = array([ [ 0, 1, 2, 3, 4],\
            [10,11,12,13,14],\
            [20,21,22,23,24],\
            [30,31,32,33,34] ])
i,j = indices((2,3))
a[i,j]
# array([[ 0, 1, 2],
#        [10, 11, 12]])]]></code>
      <code tags="inf infinite nan isfinite is finite isinf isposinf isneginf nan_to_num"><![CDATA[exp(array([1000.])) # inf = infinite = number too large to represent, machine dependent
# array([ inf])

x = array([2,-inf,1,inf])
isfinite(x) # show which elements are not nan/inf/-inf
# array([True, False, True, False], dtype=bool)

isinf(x) # show which elements are inf/-inf
# array([False, True, False, True], dtype=bool)

isposinf(x) # show which elements are inf
# array([False, False, False, True], dtype=bool)

isneginf(x) # show which elements are -inf
# array([False, True, False, False], dtype=bool)

nan_to_num(x) # replace -inf/inf with most negative/positive representable number
# array([ 2.00000000e+000, -1.79769313e+308, 1.00000000e+000, 1.79769313e+308])]]></code>
      <code tags="inner prod porduct cross"><![CDATA[x = array([1,2,3])
y = array([10,20,30])
inner(x,y) # 1x10+2x20+3x30 = 140
# 140]]></code>
      <code tags="insert value element row column before after axis rows cols columns"><![CDATA[a = array([10,20,30,40])
insert(a,[1,3],50) # insert value 50 before elements [1] and [3]
# array([10, 50, 20, 30, 50, 40])

insert(a,[1,3],[50,60]) # insert value 50 before element [1] and value 60 before element [3]
# array([10, 50, 20, 30, 60, 40])

a = array([[10,20,30],[40,50,60],[70,80,90]])
insert(a, [1,2], 100, axis=0) # insert row with values 100 before row[1] and before row[2]
# array([[ 10, 20, 30],
#        [100, 100, 100],
#        [ 40, 50, 60],
#        [100, 100, 100],
#        [ 70, 80, 90]])

insert(a, [0,1], [[100],[200]], axis=0)
# array([[100, 100, 100],
#        [ 10, 20, 30],
#        [200, 200, 200],
#        [ 40, 50, 60],
#        [ 70, 80, 90]])

insert(a, [0,1], [100,200], axis=1)
# array([[100, 10, 200, 20, 30],
#        [100, 40, 200, 50, 60],
#        [100, 70, 200, 80, 90]])]]></code>
      <code tags="inv linalg linear algebra inverse matrix"><![CDATA[from numpy.linalg import inv
a = array([[3,1,5],[1,0,8],[2,1,4]])
print a
# [[3 1 5]
#  [1 0 8]
#  [2 1 4]]

inva = inv(a) # Inverse matrix
print inva
# [[ 1.14285714 -0.14285714 -1.14285714]
#  [-1.71428571 -0.28571429 2.71428571]
#  [-0.14285714 0.14285714 0.14285714]]

dot(a,inva) # Check the result, should be eye(3) within machine precision
# array([[ 1.00000000e-00, 2.77555756e-17, 3.60822483e-16],
#        [ 0.00000000e+00, 1.00000000e+00, 0.00000000e+00],
#        [ -1.11022302e-16, 0.00000000e+00, 1.00000000e+00]])]]></code>
      <code tags="iscomplex is complex"><![CDATA[a = array([1,2,3.j])
iscomplex(a)
# array([False, False, True], dtype=bool)]]></code>
      <code tags="iscomplexobj is complex object"><![CDATA[a = array([1,2,3.j])
iscomplexobj(a)
# True

a = array([1,2,3])
iscomplexobj(a)
# False

a = array([1,2,3], dtype=complex)
iscomplexobj(a)
# True]]></code>
      <code tags="item type convert scalar"><![CDATA[a = array([5])
type(a[0])
# <type 'numpy.int32'>

a.item() # Conversion of array of size 1 to Python scalar
# 5

type(a.item())
# <type 'int'>

b = array([2,3,4])
b[1].item() # Conversion of 2nd element to Python scalar
# 3

type(b[1].item())
# <type 'int'>

b.item(2) # Return 3rd element converted to Python scalar
# 4

type(b.item(2))
# <type 'int'>

type(b[2]) # b[2] is slower than b.item(2), and there is no conversion
# <type 'numpy.int32'>]]></code>
      <code tags="ix ix_ indices"><![CDATA[a = arange(9).reshape(3,3)
print a
# [[0 1 2]
#  [3 4 5]
#  [6 7 8]]

indices = ix_([0,1,2],[1,2,0]) # trick to be used with array broadcasting
print indices
# (array([[0],
#         [1],
#         [2]]), 
#  array([[1, 2, 0]]))

print a[indices]
# [[1 2 0]
#  [4 5 3]
#  [7 8 6]]
# The latter array is the cross-product:
# [[ a[0,1] a[0,2] a[0,0]]
#  [ a[1,1] a[1,2] a[1,0]]
#  [ a[2,1] a[2,2] a[2,0]]]]]></code>
      <code tags="lexsort lexical lexicographic sort"><![CDATA[serialnr = array([1023, 5202, 6230, 1671, 1682, 5241])
height = array([40., 42., 60., 60., 98., 40.])
width = array([50., 20., 70., 60., 15., 30.])

# We want to sort the serial numbers with increasing height, _AND_
# serial numbers with equal heights should be sorted with increasing width.

indices = lexsort(keys = (width, height)) # mind the order!
indices
# array([5, 0, 1, 3, 2, 4])

for n in indices:
  print serialnr[n], height[n], width[n]
# 5241 40.0 30.0
# 1023 40.0 50.0
# 5202 42.0 20.0
# 1671 60.0 60.0
# 6230 60.0 70.0
# 1682 98.0 15.0

a = vstack([serialnr,width,height]) # Alternatively: all data in one big matrix
print a # Mind the order of the rows!
# [[ 1023. 5202. 6230. 1671. 1682. 5241.]
#  [ 50. 20. 70. 60. 15. 30.]
#  [ 40. 42. 60. 60. 98. 40.]]

indices = lexsort(a) # Sort on last row, then on 2nd last row, etc.
a.take(indices, axis=-1)
# array([[ 5241., 1023., 5202., 1671., 6230., 1682.],
#        [ 30., 50., 20., 60., 70., 15.],
#        [ 40., 40., 42., 60., 60., 98.]])]]></code>
      <code tags="linspace linear space range sequence evenly spaced"><![CDATA[linspace(0,5,num=6) # 6 evenly spaced numbers between 0 and 5 incl.
# array([ 0., 1., 2., 3., 4., 5.])

linspace(0,5,num=10) # 10 evenly spaced numbers between 0 and 5 incl.
# array([ 0. , 0.55555556, 1.11111111, 1.66666667, 2.22222222,
#         2.77777778, 3.33333333, 3.88888889, 4.44444444, 5. ])

linspace(0,5,num=10,endpoint=False) # 10 evenly spaced numbers between 0 and 5 EXCL.
# array([ 0. , 0.5, 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5])

stepsize = linspace(0,5,num=10,endpoint=False,retstep=True) # besides the usual array, also return the step size
stepsize
# (array([ 0. , 0.5, 1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5]), 0.5)

myarray, stepsize = linspace(0,5,num=10,endpoint=False,retstep=True)
stepsize
# 0.5]]></code>
      <code tags="loadtxt load txt text file csv sep separator delimiter skiprows skip rows comment usecols use columns"><![CDATA[data = loadtxt("myfile.txt") # myfile.txt contains 4 columns of numbers
t,z = data[:,0], data[:,3] # data is 2D numpy array

t,x,y,z = loadtxt("myfile.txt", unpack=True) # to unpack all columns
t,z = loadtxt("myfile.txt", usecols = (0,3), unpack=True) # to select just a few columns
data = loadtxt("myfile.txt", skiprows = 7) # to skip 7 rows from top of file
data = loadtxt("myfile.txt", comments = '!') # use '!' as comment char instead of '#'
data = loadtxt("myfile.txt", delimiter=';') # use ';' as column separator instead of whitespace
data = loadtxt("myfile.txt", dtype = int) # file contains integers instead of floats]]></code>
      <code tags="logical_and logical and"><![CDATA[logical_and(array([0,0,1,1]), array([0,1,0,1]))
# array([False, False, False, True], dtype=bool)
logical_and(array([False,False,True,True]), array([False,True,False,True]))
# array([False, False, False, True], dtype=bool)]]></code>
      <code tags="logical_not logical not"><![CDATA[logical_not(array([0,1]))
logical_not(array([False,True]))]]></code>
      <code tags="logical_or logical or"><![CDATA[logical_or(array([0,0,1,1]), array([0,1,0,1]))
logical_or(array([False,False,True,True]), array([False,True,False,True]))]]></code>
      <code tags="logical_xor logical xor"><![CDATA[logical_xor(array([0,0,1,1]), array([0,1,0,1]))
logical_xor(array([False,False,True,True]), array([False,True,False,True]))]]></code>
      <code tags="logspace logarithmic scale space range sequence evenly spaced"><![CDATA[logspace(-2, 3, num = 6) # 6 evenly spaced pts on a logarithmic scale, from 10^{-2} to 10^3 incl.
# array([ 1.00000000e-02, 1.00000000e-01, 1.00000000e+00,
#         1.00000000e+01, 1.00000000e+02, 1.00000000e+03])

logspace(-2, 3, num = 10) # 10 evenly spaced pts on a logarithmic scale, from 10^{-2} to 10^3 incl.
# array([ 1.00000000e-02, 3.59381366e-02, 1.29154967e-01,
#         4.64158883e-01, 1.66810054e+00, 5.99484250e+00,
#         2.15443469e+01, 7.74263683e+01, 2.78255940e+02,
#         1.00000000e+03])

logspace(-2, 3, num = 6, endpoint=False) # 6 evenly spaced pts on a logarithmic scale, from 10^{-2} to 10^3 EXCL.
# array([ 1.00000000e-02, 6.81292069e-02, 4.64158883e-01,
#         3.16227766e+00, 2.15443469e+01, 1.46779927e+02])

exp(linspace(log(0.01), log(1000), num=6, endpoint=False)) # for comparison
# array([ 1.00000000e-02, 6.81292069e-02, 4.64158883e-01,
#         3.16227766e+00, 2.15443469e+01, 1.46779927e+02])]]></code>
      <code tags="lstsq linalg linear algebra least squares fit fitting residuals random normal"><![CDATA[from numpy.random import normal
t = arange(0.0, 10.0, 0.05) # independent variable
y = 2.0 * sin(2.*pi*t*0.6) + 2.7 * cos(2.*pi*t*0.6) + normal(0.0, 1.0, len(t))

from numpy.linalg import lstsq
Nparam = 2 # we want to estimate 2 parameters: p_0 and p_1
A = zeros((len(t),Nparam), float) # one big array with all the f_i(t)
A[:,0] = sin(2.*pi*t*0.6) # f_0(t) stored
A[:,1] = cos(2.*pi*t*0.6) # f_1(t) stored
(p, residuals, rank, s) = lstsq(A,y)
p # our final estimate of the parameters using noisy data
# array([ 1.9315685 , 2.71165171])

residuals # sum of the residuals: sum((p[0] * A[:,0] + p[1] * A[:,1] - y)**2)
# array([ 217.23783374])

rank # rank of the array A
# 2

s # singular values of A
# array([ 10., 10.])]]></code>
      <code tags="mat matrix ravel mul multiplycation conjugate transpose inverse"><![CDATA[mat('1 3 4; 5 6 9') # matrices are always 2-dimensional
# matrix([[1, 3, 4],
#         [5, 6, 9]])

a = array([[1,2],[3,4]])
m = mat(a) # convert 2-d array to matrix
m
# matrix([[1, 2],
#         [3, 4]])

a[0] # result is 1-dimensional
# array([1, 2])

m[0] # result is 2-dimensional
# matrix([[1, 2]])

a.ravel() # result is 1-dimensional
# array([1, 2, 3, 4])

m.ravel() # result is 2-dimensional
# matrix([[1, 2, 3, 4]])

a*a # element-by-element multiplication
# array([[ 1, 4],
#        [ 9, 16]])

m*m # (algebraic) matrix multiplication
# matrix([[ 7, 10],
#        [15, 22]])

a**3 # element-wise power
# array([[ 1, 8],
#        [27, 64]])

m**3 # matrix multiplication m*m*m
# matrix([[ 37, 54],
#        [ 81, 118]])

m.T # transpose of the matrix
# matrix([[1, 3],
#        [2, 4]])

m.H # conjugate transpose (differs from .T for complex matrices)
# matrix([[1, 3],
#        [2, 4]])

m.I # inverse matrix
# matrix([[-2. , 1. ],
#        [ 1.5, -0.5]])]]></code>
      <code tags="matrix mat"><![CDATA[matrix('1 3 4; 5 6 9') # matrix is synonymous with mat
# matrix([[1, 3, 4],
#         [5, 6, 9]])]]></code>
      <code tags="max maximum axis rows cols columns"><![CDATA[a = array([10,20,30])
a.max()
# 30

a = array([[10,50,30],[60,20,40]])
a.max()
# 60

a.max(axis=0) # for each of the columns, find the maximum
# array([60, 50, 40])

a.max(axis=1) # for each of the rows, find the maximum
# array([50, 60])

max(a) # also exists, but is slower]]></code>
      <code tags="maximum max element wise"><![CDATA[a = array([1,0,5])
b = array([3,2,4])
maximum(a,b) # element-by-element comparison
# array([3, 2, 5])

max(a.tolist(),b.tolist()) # standard Python function does not give the same!
# [3, 2, 4]]]></code>
      <code tags="mean avg average axis rows cols columns"><![CDATA[a = array([1,2,7])
a.mean()
# 3.3333333333333335

a = array([[1,2,7],[4,9,6]])
a.mean()
# 4.833333333333333

a.mean(axis=0) # the mean of each of the 3 columns
# array([ 2.5, 5.5, 6.5])

a.mean(axis=1) # the mean of each of the 2 rows
# array([ 3.33333333, 6.33333333])]]></code>
      <code tags="median"><![CDATA[a = array([1,2,3,4,9])
median(a)
# 3

a = array([1,2,3,4,9,0])
median(a)
# 2.5]]></code>
      <code tags="mgrid mesh grid"><![CDATA[m = mgrid[1:3,2:5] # rectangular mesh grid with x-values [1,2] and y-values [2,3,4]
print m
# [[[1 1 1]
#   [2 2 2]]
#  [[2 3 4]
#   [2 3 4]]]

m[0,1,2] # x-value of grid point with index coordinates (1,2)
# 2

m[1,1,2] # y-value of grid point with index coordinates (1,2)
# 4]]></code>
      <code tags="min minimum axis rows cols columns"><![CDATA[a = array([10,20,30])
a.min()
# 10

a = array([[10,50,30],[60,20,40]])
a.min()
# 10

a.min(axis=0) # for each of the columns, find the minimum
# array([10, 20, 30])

a.min(axis=1) # for each of the rows, find the minimum
# array([10, 20])

min(a) # also exists, but is slower]]></code>
      <code tags="minimum min element wise"><![CDATA[a = array([1,0,5])
b = array([3,2,4])
minimum(a,b) # element-by-element comparison
# array([1, 0, 4])

min(a.tolist(),b.tolist()) # Standard Python function does not give the same!
# [1, 0, 5]]]></code>
      <code tags="multiply mul product element wise"><![CDATA[multiply(array([3,6]), array([4,7]))
# array([12, 42])]]></code>
      <code tags="nan not number is isnan finite isfinite nansum nanmax nanmin nanargmin nanargmax nan_to_num"><![CDATA[sqrt(array([-1.0]))
# array([ nan]) # nan = NaN = Not A Number

x = array([2, nan, 1])
isnan(x) # show which elements are nan
# array([False, True, False], dtype=bool)

isfinite(x) # show which elements are not nan/inf/-inf
# array([True, False, True], dtype=bool)

nansum(x) # same as sum() but ignore nan elements
# 3.0

nanmax(x) # same as max() but ignore nan elements
# 2.0

nanmin(x) # same as min() but ignore nan elements
# 1.0

nanargmin(x) # same as argmin() but ignore nan elements
# 2

nanargmax(x) # same as argmax() but ignore nan elements
# 0

nan_to_num(x) # replace all nan elements with 0.0
# array([ 2., 0., 1.])]]></code>
      <code tags="ndenumerate enumerate iter iterator"><![CDATA[a = arange(9).reshape(3,3) + 10
a
# array([[10, 11, 12],
#        [13, 14, 15],
#        [16, 17, 18]])

b = ndenumerate(a)
for position,value in b: print position,value # position is the N-dimensional index
# (0, 0) 10
# (0, 1) 11
# (0, 2) 12
# (1, 0) 13
# (1, 1) 14
# (1, 2) 15
# (2, 0) 16
# (2, 1) 17
# (2, 2) 18]]></code>
      <code tags="ndim dim number of dimensions axes"><![CDATA[a = arange(12).reshape(3,4)
a
# array([[ 0, 1, 2, 3],
#        [ 4, 5, 6, 7],
#        [ 8, 9, 10, 11]])

a.ndim # a has 2 axes
# 2

a.shape = (2,2,3)
# array([[[ 0, 1, 2],
#         [ 3, 4, 5]],
#        [[ 6, 7, 8],
#         [ 9, 10, 11]]])

a.ndim # now a has 3 axes
# 3

len(a.shape) # same as ndim
# 3]]></code>
      <code tags="ndindex index enumerate iter iterator"><![CDATA[for index in ndindex(4,3,2):
  print index
# (0,0,0)
# (0,0,1)
# (0,1,0)
# ...
# (3,1,1)
# (3,2,0)
# (3,2,1)]]></code>
      <code tags="newaxis add new axis axes dimension"><![CDATA[x = arange(3)
x
# array([0, 1, 2])

x[:,newaxis] # add a new dimension/axis
# array([[0],
#        [1],
#        [2]])

x[:,newaxis,newaxis] # add two new dimensions/axes
# array([[[0]],
#        [[1]],
#        [[2]]])

x[:,newaxis] * x
# array([[0, 0, 0],
#        [0, 1, 2],
#        [0, 2, 4]])

y = arange(3,6)
x[:,newaxis] * y # outer product, same as outer(x,y)
# array([[ 0, 0, 0],
#        [ 3, 4, 5],
#        [ 6, 8, 10]])

x.shape
# (3,)

x[newaxis,:].shape # x[newaxis,:] is equivalent to x[newaxis] and x[None]
# (1,3)

x[:,newaxis].shape
# (3,1)]]></code>
      <code tags="nonzero non zero indices elements"><![CDATA[x = array([1,0,2,-1,0,0,8])
indices = x.nonzero() # find the indices of the nonzero elements
indices
# (array([0, 2, 3, 6]),)

x[indices]
# array([1, 2, -1, 8])

y = array([[0,1,0],[2,0,3]])
indices = y.nonzero()
indices
# (array([0, 1, 1]), array([1, 0, 2]))

y[indices[0],indices[1]] # one way of doing it, explains what's in indices[0] and indices[1]
# array([1, 2, 3])

y[indices] # this way is shorter
# array([1, 2, 3])

y = array([1,3,5,7])
indices = (y >= 5).nonzero()
y[indices]
# array([5, 7])

nonzero(y) # function also exists
# (array([0, 1, 2, 3]),)]]></code>
      <code tags="ogrid grid broadcasting"><![CDATA[x,y = ogrid[0:3,0:3] # x and y are useful to use with broadcasting rules
x
# array([[0],
#        [1],
#        [2]])

y
# array([[0, 1, 2]])

print x*y # example how to use broadcasting rules
# [[0 0 0]
#  [0 1 2]
#  [0 2 4]]]]></code>
      <code tags="ones"><![CDATA[ones(5)
# array([ 1., 1., 1., 1., 1.])
ones((2,3), int)
# array([[1, 1, 1],
#        [1, 1, 1]])]]></code>
      <code tags="ones_like ones like same shape"><![CDATA[a = array([[1,2,3],[4,5,6]])
ones_like(a) # ones initialised array with the same shape and datatype as 'a'
# array([[1, 1, 1],
#        [1, 1, 1]])]]></code>
      <code tags="outer product"><![CDATA[x = array([1,2,3])
y = array([10,20,30])
outer(x,y) # outer product
# array([[10, 20, 30],
#        [20, 40, 60],
#        [30, 60, 90]])]]></code>
      <code tags="permutation perm random"><![CDATA[from numpy.random import permutation
permutation(4) # permutation of integers from 0 to 3
# array([0, 3, 1, 2])
permutation(4) # another permutation of integers from 0 to 3
# array([2, 1, 0, 3])
permutation(4) # yet another permutation of integers from 0 to 3
# array([3, 0, 2, 1])]]></code>
      <code tags="piecewise piece wise condition"><![CDATA[f1 = lambda x: x*x
f2 = lambda x: 2*x
x = arange(-2.,3.,0.1)
condition = (x>1)&(x<2) # boolean array
y = piecewise(x,condition, [f1,1.]) # if condition is true, return f1, otherwise 1.
print y
# [ 1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.
#   1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.    1.
#   1.    1.    1.    1.    1.    1.21  1.44  1.69  1.96  2.25  2.56  2.89
#   3.24  3.61  1.    1.    1.    1.    1.    1.    1.    1.    1.    1.  ]]]></code>
      <code tags="pinv linalg linear algebra svd lstsq least squares pseudo inverse matrix"><![CDATA[from numpy.linalg import pinv,svd,lstsq
A = array([[1., 3., 5.],[2., 4., 6.]])
b = array([1., 3.])

# Question: find x such that ||A*x-b|| is minimal
# Answer: x = pinvA * b, with pinvA the pseudo-inverse of A

pinvA = pinv(A)
print pinvA
# [[-1.33333333 1.08333333]
#  [-0.33333333 0.33333333]
#  [ 0.66666667 -0.41666667]]

x = dot(pinvA, b)
print x
# [ 1.91666667 0.66666667 -0.58333333]

# Relation with least-squares minimisation lstsq()

x,resids,rank,s = lstsq(A,b)
print x # the same solution for x as above
# [ 1.91666667 0.66666667 -0.58333333]

# Relation with singular-value decomposition svd()

U,sigma,V = svd(A)
S = zeros_like(A.transpose())
for n in range(len(sigma)): S[n,n] = 1. / sigma[n]
dot(V.transpose(), dot(S, U.transpose())) # = pinv(A)
# array([[-1.33333333, 1.08333333],
#        [-0.33333333, 0.33333333],
#        [ 0.66666667, -0.41666667]])]]></code>
      <code tags="poisson distribution random"><![CDATA[from numpy.random import *
poisson(lam=0.5, size=(2,3)) # poisson distribution lambda=0.5
# array([[2, 0, 0],
#        [1, 1, 0]])]]></code>
      <code tags="poly1d polynomial roots coefficients quotient remainder evaluate order derivate integrate integral"><![CDATA[p1 = poly1d([2,3],r=1) # specify polynomial by its roots
print p1
#    2
# 1 x - 5 x + 6

p2 = poly1d([2,3],r=0) # specify polynomial by its coefficients
print p2
# 2 x + 3

print p1+p2 # +,-,*,/ and even ** are supported
#    2
# 1 x - 3 x + 9

quotient,remainder = p1/p2 # division gives a tupple with the quotient and remainder
print quotient,remainder
# 0.5 x - 3
# 15

p3 = p1*p2
print p3
#    3 2
# 2 x - 7 x - 3 x + 18

p3([1,2,3,4]) # evaluate the polynomial in the values [1,2,3,4]
# array([10, 0, 0, 22])

p3[2] # the coefficient of x**2
# -7

p3.r # the roots of the polynomial
# array([-1.5, 3. , 2. ])

p3.c # the coefficients of the polynomial
# array([ 2, -7, -3, 18])

p3.o # the order of the polynomial
# 3

print p3.deriv(m=2) # the 2nd derivative of the polynomial
# 12 x - 14

print p3.integ(m=2,k=[1,2]) # integrate polynomial twice and use [1,2] as integration constants
#      5 4 3 2
# 0.1 x - 0.5833 x - 0.5 x + 9 x + 1 x + 2]]></code>
      <code tags="polyfit polynomial fit data"><![CDATA[x = array([1,2,3,4,5])
y = array([6, 11, 18, 27, 38])
polyfit(x,y,2) # fit a 2nd degree polynomial to the data, result is x**2 + 2x + 3
# array([ 1., 2., 3.])

polyfit(x,y,1) # fit a 1st degree polynomial (straight line), result is 8x-4
# array([ 8., -4.])]]></code>
      <code tags="prod product mul multiply axis rows cols columns"><![CDATA[a = array([1,2,3])
a.prod() # 1 * 2 * 3 = 6
# 6

prod(a) # also exists
# 6

a = array([[1,2,3],[4,5,6]])
a.prod(dtype=float) # specify type of output
# 720.0

a.prod(axis=0) # for each of the 3 columns: product
# array([ 4, 10, 18])

a.prod(axis=1) # for each of the two rows: product
# array([ 6, 120])]]></code>
      <code tags="ptp peak to axis rows cols columns maximum minimum range"><![CDATA[a = array([5,15,25])
a.ptp() # peak-to-peak = maximum - minimum
# 20

a = array([[5,15,25],[3,13,33]])
a.ptp()
# 30

a.ptp(axis=0) # peak-to-peak value for each of the 3 columns
# array([2, 2, 8])

a.ptp(axis=1) # peak-to-peak value for each of the 2 rows
# array([20, 30])]]></code>
      <code tags="put"><![CDATA[a = array([10,20,30,40])
a.put([60,70,80], [0,3,2]) # first values, then indices
a
# array([60, 20, 80, 70])

a[[0,3,2]] = [60,70,80] # same effect
a.put([40,50], [0,3,2,1]) # if value array is too short, it is repeated
a
# array([40, 50, 40, 50])

put(a, [0,3], [90]) # also exists, but here FIRST indices, THEN values
a
# array([90, 50, 40, 90])]]></code>
      <code tags="putmask put mask"><![CDATA[a = array([10,20,30,40])
mask = array([True,False,True,True]) # size mask = size a
a.putmask([60,70,80,90], mask) # first values, then the mask
a
# array([60, 20, 80, 90])

a = array([10,20,30,40])
a[mask] # reference
# array([60, 80, 90])

a[mask] = array([60,70,80,90]) # NOT exactly the same as putmask
a
# array([60, 20, 70, 80])

a.putmask([10,90], mask) # if value array is too short, it is repeated
a
# array([10, 20, 10, 90])

putmask(a, mask, [60,70,80,90]) # also exists, but here FIRST mask, THEN values]]></code>
      <code tags="r_ arange range concatenate concatenation along axis rows cols columns"><![CDATA[r_[1:5] # same as arange(1,5)
# array([1, 2, 3, 4])

r_[1:10:4] # same as arange(1,10,4)
# array([1, 5, 9])

r_[1:10:4j] # same as linspace(1,10,4), 4 equally-spaced elements between 1 and 10 inclusive
# array([ 1., 4., 7., 10.])

r_[1:5,7,1:10:4] # sequences separated with commas are concatenated
# array([1, 2, 3, 4, 7, 1, 5, 9])

r_['r', 1:3] # return a matrix. If 1-d, result is a 1xN matrix
# matrix([[1, 2]])

r_['c',1:3] # return a matrix. If 1-d, result is a Nx1 matrix
# matrix([[1],
#         [2]])

a = array([[1,2,3],[4,5,6]])
r_[a,a] # concatenation along 1st (default) axis (row-wise, that's why it's called r_)
# array([[1, 2, 3],
#        [4, 5, 6],
#        [1, 2, 3],
#        [4, 5, 6]])

r_['-1',a,a] # concatenation along last axis, same as c_[a,a]
# array([[1, 2, 3, 1, 2, 3],
#        [4, 5, 6, 4, 5, 6]])]]></code>
      <code tags="rand random"><![CDATA[from numpy.random import *
rand(3,2)
# array([[ 0.65159297, 0.78872335],
#        [ 0.09385959, 0.02834748],
#        [ 0.8357651 , 0.43276707]])]]></code>
      <code tags="randn random normal"><![CDATA[from numpy.random import *
randn(2,3)
# array([[ 1.22497074, -0.29508896, -0.75040033],
#        [-0.54822685, -0.98032155, -1.40467696]])]]></code>
      <code tags="random_integers randint random integers"><![CDATA[from numpy.random import *
random_integers(-1,5,(2,2))
# array([[ 3, -1],
#        [-1, 0]])]]></code>
      <code tags="random_sample random sample"><![CDATA[from numpy.random import *
random_sample((3,2))
# array([[ 0.76228008, 0.00210605],
#        [ 0.44538719, 0.72154003],
#        [ 0.22876222, 0.9452707 ]])]]></code>
      <code tags="ravel 1d copy reference slice flat flatten segment"><![CDATA[a = array([[1,2],[3,4]])
a.ravel() # 1-d version of a
# array([1, 2, 3, 4])

b = a[:,0].ravel() # a[:,0] does not occupy a single memory segment, thus b is a copy, not a reference
b
# array([1, 3])

c = a[0,:].ravel() # a[0,:] occupies a single memory segment, thus c is a reference, not a copy
c
# array([1, 2])

b[0] = -1
c[1] = -2
a
# array([[ 1, -2],
#        [ 3, 4]])

ravel(a) # also exists]]></code>
      <code tags="real"><![CDATA[a = array([1+2j,3+4j,5+6j])
a.real

# array([ 1., 3., 5.])

a.real = 9
a
# array([ 9.+2.j, 9.+4.j, 9.+6.j])

a.real = array([9,8,7])
a
# array([ 9.+2.j, 8.+4.j, 7.+6.j])]]></code>
      <code tags="recarray fromrecords from records rec"><![CDATA[num = 2
a = recarray(num, formats='i4,f8,f8',names='id,x,y')
a['id'] = [3,4]
a['id']
# array([3, 4])

a = rec.fromrecords([(35,1.2,7.3),(85,9.3,3.2)], names='id,x,y') # fromrecords is in the numpy.rec submodule
a['id']
# array([35, 85])]]></code>
      <code tags="reduce opreand operation axis rows cols columns"><![CDATA[add.reduce(array([1.,2.,3.,4.])) # computes ((((1.)+2.)+3.)+4.)
# 10.0

multiply.reduce(array([1.,2.,3.,4.])) # works also with other operands. Computes ((((1.)*2.)*3.)*4.)
# 24.0

add.reduce(array([[1,2,3],[4,5,6]]), axis = 0) # reduce every column separately
# array([5, 7, 9])

add.reduce(array([[1,2,3],[4,5,6]]), axis = 1) # reduce every row separately
# array([ 6, 15])]]></code>
      <code tags="repeat axis rows cols columns"><![CDATA[repeat(7., 4)
# array([ 7., 7., 7., 7.])

a = array([10,20])
a.repeat([3,2])
# array([10, 10, 10, 20, 20])

repeat(a, [3,2]) # also exists
a = array([[10,20],[30,40]])
a.repeat([3,2,1,1])
# array([10, 10, 10, 20, 20, 30, 40])

a.repeat([3,2],axis=0)
# array([[10, 20],
#        [10, 20],
#        [10, 20],
#        [30, 40],
#        [30, 40]])

a.repeat([3,2],axis=1)
# array([[10, 10, 10, 20, 20],
#        [30, 30, 30, 40, 40]])]]></code>
      <code tags="reshape change modify shape rows cols columns missing"><![CDATA[x = arange(12)
x.reshape(3,4) # array with 3 rows and 4 columns. 3x4=12. Total number of elements is always the same.
# array([[ 0, 1, 2, 3],
#        [ 4, 5, 6, 7],
#        [ 8, 9, 10, 11]])

x.reshape(3,2,2) # 3x2x2 array; 3x2x2 = 12. x itself does _not_ change.
# array([[[ 0, 1],
#         [ 2, 3]],
#        [[ 4, 5],
#         [ 6, 7]],
#        [[ 8, 9],
#         [10, 11]]])

x.reshape(2,-1) # 'missing' -1 value n is calculated so that 2xn=12, so n=6
# array([[ 0, 1, 2, 3, 4, 5],
#        [ 6, 7, 8, 9, 10, 11]])

x.reshape(12) # reshape(1,12) is not the same as reshape(12)
# array([0,1,2,3,4,5,6,7,8,9,10,11])

reshape(x,(2,6)) # Separate function reshape() also exists]]></code>
      <code tags="resize reshape shape change size reallocate allocate memory"><![CDATA[a = array([1,2,3,4])
a.resize(2,2) # changes shape of 'a' itself
print a
# [[1 2]
#  [3 4]]

a.resize(3,2) # reallocates memoy of 'a' to change nr of elements, fills excess elements with 0
print a
# [[1 2]
#  [3 4]
#  [0 0]]

a.resize(2,4)
print a
# [[1 2 3 4]
#  [0 0 0 0]]

a.resize(2,1) # throws away elements of 'a' to fit new shape
print a
# [[1]
#  [2]]

# But, there is a caveat:

b = array([1,2,3,4])
c = b # c is reference to b, it doesn't 'own' its data
c.resize(2,2) # no problem, nr of elements doesn't change
c.resize(2,3) # doesn't work, c is only a reference
# Traceback (most recent call last):
#   File "<stdin>", line 1, in ?
# ValueError: cannot resize an array that has been referenced or is referencing
# another array in this way. Use the resize function

b.resize(2,3) # doesn't work, b is referenced by another array
# Traceback (most recent call last):
#   File "<stdin>", line 1, in ?
# ValueError: cannot resize an array that has been referenced or is referencing
# another array in this way. Use the resize function

# And it's not always obvious what the reference is:

d = arange(4)
d
# array([0, 1, 2, 3])

d.resize(5) # doesn't work, but where's the reference?
# Traceback (most recent call last):
#   File "<stdin>", line 1, in ?
# ValueError: cannot resize an array that has been referenced or is referencing
# another array in this way. Use the resize function

_ # '_' was a reference to d!
# array([0, 1, 2, 3])

d = resize(d, 5) # this does work, however
d
# array([0, 1, 2, 3, 0])]]></code>
      <code tags="rollaxis roll axis transpose swap change"><![CDATA[a = arange(3*4*5).reshape(3,4,5)
a.shape
# (3, 4, 5)

b = rollaxis(a,1,0) # transpose array so that axis 1 is 'rolled' before axis 0
b.shape
# (4, 3, 5)

b = rollaxis(a,0,2) # transpose array so that axis 0 is 'rolled' before axis 2
b.shape
# (4, 3, 5)]]></code>
      <code tags="round decimals place"><![CDATA[array([1.2345, -1.647]).round() # rounds the items. Type remains float64.
# array([ 1., -2.])

array([1, -1]).round() # integer arrays stay as they are
# array([ 1, -1])

array([1.2345, -1.647]).round(decimals=1) # round to 1 decimal place
# array([ 1.2, -1.6])

array([1.2345+2.34j, -1.647-0.238j]).round() # both real and complex parts are rounded
# array([ 1.+2.j, -2.-0.j])

array([0.0, 0.5, 1.0, 1.5, 2.0, 2.5]).round() # numpy rounds x.5 to nearest even.
# array([ 0., 0., 1., 2., 2., 2.])

a = zeros(3, dtype=int)
array([1.2345, -1.647, 3.141]).round(out=a) # different output arrays may be specified
# array([ 1, -2, 3])

a # and the output is cast to the new type
# array([ 1, -2, 3])

round_(array([1.2345, -1.647])) # round_ is the functional form. -> a copy.
# array([ 1., -2.])

around(array([1.2345, -1.647])) # around is an alias of round_.
# array([ 1., -2.])]]></code>
      <code tags="rot90 rotate matrix 90 degrees"><![CDATA[a = arange(12).reshape(4,3)
a
# array([[ 0, 1, 2],
#        [ 3, 4, 5],
#        [ 6, 7, 8],
#        [ 9, 10, 11]])

rot90(a) # 'rotate' the matrix 90 degrees
# array([[ 2, 5, 8, 11],
#        [ 1, 4, 7, 10],
#        [ 0, 3, 6, 9]])]]></code>
      <code tags="s_ slice"><![CDATA[s_[1:5] # easy slice generating. See r_[] examples.
# slice(1, 5, None)

s_[1:10:4]
# slice(1, 10, 4)

s_[1:10:4j]
# slice(1, 10, 4j)

s_['r',1:3] # to return a matrix. If 1-d, result is a 1xN matrix
# ('r', slice(1, 3, None))

s_['c',1:3] # to return a matrix. If 1-d, result is a Nx1 matrix
# ('c', slice(1, 3, None))]]></code>
      <code tags="savetxt save txt text file csv delimiter"><![CDATA[savetxt("myfile.txt", data) # data is 2D array
savetxt("myfile.txt", x) # x is 1D array. 1 column in file.
savetxt("myfile.txt", (x,y)) # x,y are 1D arrays. 2 rows in file.
savetxt("myfile.txt", transpose((x,y))) # x,y are 1D arrays. 2 columns in file.
savetxt("myfile.txt", transpose((x,y)), fmt='%6.3f') # use new format instead of '%.18e'
savetxt("myfile.txt", data, delimiter = ';') # use ';' to separate columns instead of space]]></code>
      <code tags="searchsorted search find sorted binary"><![CDATA[a = array([1,2,2,3]) # a is 1-D and in ascending order.
a.searchsorted(2) # side defaults to "left"
# 1 # a[1] is the first element in a >= 2

a.searchsorted(2, side='right') # look for the other end of the run of twos
# 3 # a[3] is the first element in a > 2

a.searchsorted(4) # 4 is greater than any element in a
# 4 # the returned index is 1 past the end of a.

a.searchsorted([[1,2],[2,3]]) # whoa, fancy keys
# array([[0, 1], # the returned array has the same shape as the keys
#        [1, 3]])

searchsorted(a,2) # there is a functional form
# 1]]></code>
      <code tags="seed pseudo random number generator"><![CDATA[from numpy.random import *
seed([1]) # seed the pseudo-random number generator
rand(3)
# array([ 0.13436424, 0.84743374, 0.76377462])

seed([1])
rand(3)
# array([ 0.13436424, 0.84743374, 0.76377462])

rand(3)
# array([ 0.25506903, 0.49543509, 0.44949106])]]></code>
      <code tags="select choose"><![CDATA[x = array([5., -2., 1., 0., 4., -1., 3., 10.])
select([x < 0, x == 0, x <= 5], [x-0.1, 0.0, x+0.2], default = 100.)
# array([ 5.2, -2.1, 1.2, 0. , 4.2, -1.1, 3.2, 100. ])

# This is how it works:

result = zeros_like(x)
for n in range(len(x)):
  if x[n] < 0: result[n] = x[n]-0.1 # The order of the conditions matters. The first one that
  elif x[n] == 0: result[n] = 0.0 # matches, will be 'selected'.
  elif x[n] <= 5: result[n] = x[n]+0.2
  else: result[n] = 100. # The default is used when none of the conditions match

result
# array([ 5.2, -2.1, 1.2, 0. , 4.2, -1.1, 3.2, 100. ])]]></code>
      <code tags="set_printoptions set print options precision decimal point digits suppress small values"><![CDATA[x = array([pi, 1.e-200])
x
# array([ 3.14159265e+000, 1.00000000e-200])

set_printoptions(precision=3, suppress=True) # 3 digits behind decimal point + suppress small values
x
# array([ 3.142, 0. ])

help(set_printoptions) # see help() for keywords 'threshold','edgeitems' and 'linewidth']]></code>
      <code tags="shape reshape"><![CDATA[x = arange(12)
x.shape
# (12,)

x.shape = (3,4) # array with 3 rows and 4 columns. 3x4=12. Total number of elements is always the same.
x
# array([[ 0, 1, 2, 3],
#        [ 4, 5, 6, 7],
#        [ 8, 9, 10, 11]])

x.shape = (3,2,2) # 3x2x2 array; 3x2x2 = 12. x itself _does_ change, unlike reshape().
x
# array([[[ 0, 1],
#         [ 2, 3]],
#        [[ 4, 5],
#         [ 6, 7]],
#        [[ 8, 9],
#         [10, 11]]])

x.shape = (2,-1) # 'missing' -1 value n is calculated so that 2xn=12, so n=6
x
# array([[ 0, 1, 2, 3, 4, 5],
#        [ 6, 7, 8, 9, 10, 11]])

x.shape = 12 # x.shape = (1,12) is not the same as x.shape = 12
x
# array([0,1,2,3,4,5,6,7,8,9,10,11])]]></code>
      <code tags="shuffle random sequence"><![CDATA[from numpy.random import shuffle
x = array([1,50,-1,3])
shuffle(x) # shuffle the elements of x
print x
# [-1 3 50 1]

x = ['a','b','c','z']
shuffle(x) # works with any sequence
print x
# ['a', 'c', 'z', 'b']]]></code>
      <code tags="slice"><![CDATA[s = slice(3,9,2) # slice objects exist outside numpy
a = arange(20)
a[s]
# array([3, 5, 7])

a[3:9:2] # same thing
# array([3, 5, 7])]]></code>
      <code tags="solve linalg linear algebra system equations"><![CDATA[from numpy.linalg import solve

# The system of equations we want to solve for (x0,x1,x2):
# 3 * x0 + 1 * x1 + 5 * x2 = 6
# 1 * x0 + 8 * x2 = 7
# 2 * x0 + 1 * x1 + 4 * x2 = 8

a = array([[3,1,5],[1,0,8],[2,1,4]])
b = array([6,7,8])
x = solve(a,b)
print x # This is our solution
# [-3.28571429 9.42857143 1.28571429]

dot(a,x) # Just checking if we indeed obtain the righthand side
# array([ 6., 7., 8.])]]></code>
      <code tags="sometrue some true exists"><![CDATA[b = array([True, False, True, True])
sometrue(b)
# True

a = array([1, 5, 2, 7])
sometrue(a >= 5)
# True]]></code>
      <code tags="sort quicksort mergesort heapsort quick merge heap axis rows cols columns"><![CDATA[a = array([2,0,8,4,1])
a.sort() # in-place sorting with quicksort (default)
a
# array([0, 1, 2, 4, 8])

a.sort(kind='mergesort') # algorithm options are 'quicksort', 'mergesort' and 'heapsort'
a = array([[8,4,1],[2,0,9]])
a.sort(axis=0)
a
# array([[2, 0, 1],
#        [8, 4, 9]])

a = array([[8,4,1],[2,0,9]])
a.sort(axis=1) # default axis = -1
a
# array([[1, 4, 8],
#        [0, 2, 9]])

sort(a) # there is a functional form]]></code>
      <code tags="split row column wise axis rows cols columns"><![CDATA[a = array([[1,2,3,4],[5,6,7,8]])
split(a,2,axis=0) # split a in 2 parts. row-wise
# array([[1, 2, 3, 4]]), array([[5, 6, 7, 8]])]

split(a,4,axis=1) # split a in 4 parts, column-wise
# [array([[1],
#         [5]]), 
#  array([[2],
#         [6]]), 
#  array([[3],
#         [7]]), 
#  array([[4],
#         [8]])]

split(a,3,axis=1) # impossible to split in 3 equal parts -> error (SEE: array_split)
# Traceback (most recent call last):
# ValueError: array split does not result in an equal division

split(a,[2,3],axis=1) # make a split before the 2nd and the 3rd column
# [array([[1, 2],
#         [5, 6]]), 
#  array([[3],
#         [7]]), 
#  array([[4],
#         [8]])]]]></code>
      <code tags="squeeze remove dim dimensions"><![CDATA[a = arange(6)
a = a.reshape(1,2,1,1,3,1)
a
# array([[[[[[0],
#            [1],
#            [2]]]],
#         [[[[3],
#            [4],
#            [5]]]]]])

a.squeeze() # result has shape 2x3, all dimensions with length 1 are removed
# array([[0, 1, 2],
#        [3, 4, 5]])

squeeze(a) # also exists]]></code>
      <code tags="std standard deviation axis rows cols columns"><![CDATA[a = array([1.,2,7])
a.std() # normalized by N (not N-1)
# 2.6246692913372702

a = array([[1.,2,7],[4,9,6]])
a.std()
# 2.793842435706702

a.std(axis=0) # standard deviation of each of the 3 columns
# array([ 1.5, 3.5, 0.5])

a.std(axis=1) # standard deviation of each of the 2 columns
# array([ 2.62466929, 2.05480467])]]></code>
      <code tags="standard_normal standard normal random randn"><![CDATA[from numpy.random import *
standard_normal((2,3))
# array([[ 1.12557608, -0.13464922, -0.35682992],
#        [-1.54090277, 1.21551589, -1.82854551]])]]></code>
      <code tags="sum axis rows cols columns"><![CDATA[a = array([1,2,3])
a.sum()
# 6
sum(a) # also exists

a = array([[1,2,3],[4,5,6]])
a.sum()
# 21

a.sum(dtype=float) # specify type of output
# 21.0

a.sum(axis=0) # sum over rows for each of the 3 columns
# array([5, 7, 9])

a.sum(axis=1) # sum over columns for each of the 2 rows
# array([ 6, 15])]]></code>
      <code tags="svd linalg linear algebra singular value decomposition"><![CDATA[from numpy.linalg import svd
A = array([[1., 3., 5.],[2., 4., 6.]]) # A is a (2x3) matrix
U,sigma,V = svd(A)
print U # U is a (2x2) unitary matrix
# [[-0.61962948 -0.78489445]
#  [-0.78489445 0.61962948]]

print sigma # non-zero diagonal elements of Sigma
# [ 9.52551809 0.51430058]

print V # V is a (3x3) unitary matrix
# [[-0.2298477 -0.52474482 -0.81964194]
#  [ 0.88346102 0.24078249 -0.40189603]
#  [ 0.40824829 -0.81649658 0.40824829]]

Sigma = zeros_like(A) # constructing Sigma from sigma
n = min(A.shape)
Sigma[:n,:n] = diag(sigma)
print dot(U,dot(Sigma,V)) # A = U * Sigma * V
# [[ 1. 3. 5.]
#  [ 2. 4. 6.]]]]></code>
      <code tags="swapaxes swap axes change axis"><![CDATA[a = arange(30)
a = a.reshape(2,3,5)
a
# array([[[ 0, 1, 2, 3, 4],
#         [ 5, 6, 7, 8, 9],
#         [10, 11, 12, 13, 14]],
#        [[15, 16, 17, 18, 19],
#         [20, 21, 22, 23, 24],
#         [25, 26, 27, 28, 29]]])

b = a.swapaxes(1,2) # swap the 2nd and the 3rd axis
b
# array([[[ 0, 5, 10],
#         [ 1, 6, 11],
#         [ 2, 7, 12],
#         [ 3, 8, 13],
#         [ 4, 9, 14]],
#        [[15, 20, 25],
#         [16, 21, 26],
#         [17, 22, 27],
#         [18, 23, 28],
#         [19, 24, 29]]])

b.shape
# (2, 5, 3)

b[0,0,0] = -1 # be aware that b is a reference, not a copy
print a[0,0,0]]]></code>
      <code tags="T transpose"><![CDATA[x = array([[1.,2.],[3.,4.]])
x
# array([[ 1., 2.],
#        [ 3., 4.]])

x.T # shortcut for transpose()
# array([[ 1., 3.],
#        [ 2., 4.]])]]></code>
      <code tags="take select indices axis rows cols columns"><![CDATA[a = array([10,20,30,40])
a.take([0,0,3]) # [0,0,3] is a set of indices
# array([10, 10, 40])

a[[0,0,3]] # the same effect
# array([10, 10, 40])

a.take([[0,1],[0,1]]) # shape of return array depends on shape of indices array
# array([[10, 20],
#        [10, 20]])

a = array([[10,20,30],[40,50,60]])
a.take([0,2],axis=1)
# array([[10, 30],
#        [40, 60]])

take(a,[0,2],axis=1) # also exists]]></code>
      <code tags="tensordot tensor dot product sum"><![CDATA[a = arange(60.).reshape(3,4,5)
b = arange(24.).reshape(4,3,2)
c = tensordot(a,b, axes=([1,0],[0,1])) # sum over the 1st and 2nd dimensions
c.shape
# (5,2)

# A slower but equivalent way of computing the same:
c = zeros((5,2))
for i in range(5):
  for j in range(2):
    for k in range(3):
      for n in range(4):
        c[i,j] += a[k,n,i] * b[n,k,j]]]></code>
      <code tags="tile copy concatenate 1d 2d arrays scalars"><![CDATA[a = array([10,20])
tile(a, (3,2)) # concatenate 3x2 copies of a together
# array([[10, 20, 10, 20],
#        [10, 20, 10, 20],
#        [10, 20, 10, 20]])

tile(42.0, (3,2)) # works for scalars, too
# array([[ 42., 42.],
#        [ 42., 42.],
#        [ 42., 42.]])

tile([[1,2],[4,8]], (2,3)) # works for 2-d arrays and list literals, too
# array([[1, 2, 1, 2, 1, 2],
#        [4, 8, 4, 8, 4, 8],
#        [1, 2, 1, 2, 1, 2],
#        [4, 8, 4, 8, 4, 8]])]]></code>
      <code tags="tofile save convert to file ascii binary format"><![CDATA[x = arange(10.)
y = x**2
y.tofile("myfile.dat") # binary format
y.tofile("myfile.txt", sep=' ', format = "%e") # ascii format, one row, exp notation, values separated by 1 space
y.tofile("myfile.txt", sep='\n', format = "%e") # ascii format, one column, exponential notation]]></code>
      <code tags="tolist convert to standard list"><![CDATA[a = array([[1,2],[3,4]])
a.tolist() # convert to a standard python list
# [[1, 2], [3, 4]]]]></code>
      <code tags="trace diagonal sum offset"><![CDATA[a = arange(12).reshape(3,4)
a
# array([[ 0, 1, 2, 3],
#        [ 4, 5, 6, 7],
#        [ 8, 9, 10, 11]])

a.diagonal()
# array([ 0, 5, 10])

a.trace()
# 15

a.diagonal(offset=1)
# array([ 1, 6, 11])

a.trace(offset=1)
# 18]]></code>
      <code tags="transpose T"><![CDATA[a = array([[1,2,3],[4,5,6]])
print a.shape
# (2, 3)

b = a.transpose()
print b
# [[1 4]
#  [2 5]
#  [3 6]]

print b.shape
# (3, 2)]]></code>
      <code tags="transpose multidimensional multi dim dimensional axis"><![CDATA[a = arange(30)
a = a.reshape(2,3,5)
a
# array([[[ 0, 1, 2, 3, 4],
#         [ 5, 6, 7, 8, 9],
#         [10, 11, 12, 13, 14]],
#        [[15, 16, 17, 18, 19],
#         [20, 21, 22, 23, 24],
#         [25, 26, 27, 28, 29]]])

b = a.transpose()
b
# array([[[ 0, 15],
#         [ 5, 20],
#         [10, 25]],
#        [[ 1, 16],
#         [ 6, 21],
#         [11, 26]],
#        [[ 2, 17],
#         [ 7, 22],
#         [12, 27]],
#        [[ 3, 18],
#         [ 8, 23],
#         [13, 28]],
#        [[ 4, 19],
#         [ 9, 24],
#         [14, 29]]])

b.shape
# (5, 3, 2)

b = a.transpose(1,0,2) # First axis 1, then axis 0, then axis 2
b
# array([[[ 0, 1, 2, 3, 4],
#         [15, 16, 17, 18, 19]],
#        [[ 5, 6, 7, 8, 9],
#         [20, 21, 22, 23, 24]],
#        [[10, 11, 12, 13, 14],
#         [25, 26, 27, 28, 29]]])

b.shape
# (3, 2, 5)

b = transpose(a, (1,0,2)) # A separate transpose() function also exists]]></code>
      <code tags="tri triangular matrix"><![CDATA[tri(3,4,k=0,dtype=float) # 3x4 matrix of Floats, triangular, the k=0-th diagonal and below is 1, the upper part is 0
# array([[ 1., 0., 0., 0.],
#        [ 1., 1., 0., 0.],
#        [ 1., 1., 1., 0.]])

tri(3,4,k=1,dtype=int)
# array([[1, 1, 0, 0],
#        [1, 1, 1, 0],
#        [1, 1, 1, 1]])]]></code>
      <code tags="tril lower triangular matrix"><![CDATA[a = arange(10,100,10).reshape(3,3)
a
# array([[10, 20, 30],
#        [40, 50, 60],
#        [70, 80, 90]])

tril(a,k=0)
# array([[10, 0, 0],
#        [40, 50, 0],
#        [70, 80, 90]])

tril(a,k=1)
# array([[10, 20, 0],
#        [40, 50, 60],
#        [70, 80, 90]])]]></code>
      <code tags="trim_zeros trim strip zeros"><![CDATA[x = array([0, 0, 0, 1, 2, 3, 0, 0])
trim_zeros(x,'f') # remove zeros at the front
# array([1, 2, 3, 0, 0])

trim_zeros(x,'b') # remove zeros at the back
# array([0, 0, 0, 1, 2, 3])

trim_zeros(x,'bf') # remove zeros at the back and the front
# array([1, 2, 3])]]></code>
      <code tags="triu upper triangular matrix"><![CDATA[a = arange(10,100,10).reshape(3,3)
a
# array([[10, 20, 30],
#        [40, 50, 60],
#        [70, 80, 90]])

triu(a,k=0)
# array([[10, 20, 30],
#        [ 0, 50, 60],
#        [ 0, 0, 90]])

triu(a,k=1)
# array([[ 0, 20, 30],
#        [ 0, 0, 60],
#        [ 0, 0, 0]])]]></code>
      <code tags="typeDict type dictionary list"><![CDATA[typeDict['short']
# <type 'numpy.int16'>

typeDict['uint16']
# <type 'numpy.uint16'>

typeDict['void']
# <type 'numpy.void'>

typeDict['S']
# <type 'numpy.string_'>]]></code>
      <code tags="uniform random range"><![CDATA[from numpy.random import *
uniform(low=0,high=10,size=(2,3)) # uniform numbers in range [0,10)
# array([[ 6.66689951, 4.50623001, 4.69973967],
#        [ 6.52977732, 3.24688284, 5.01917021]])]]></code>
      <code tags="unique remove duplicates"><![CDATA[x = array([2,3,2,1,0,3,4,0])
unique(x) # remove double values
# array([0, 1, 2, 3, 4])]]></code>
      <code tags="unique1d flat unique return index inverse"><![CDATA[unique1d([1, 1, 2, 2, 3, 3])
# array([1, 2, 3])

a = array([[1, 1], [2, 3]])
unique1d(a)
# array([1, 2, 3])

unique1d([1,2,6,4,2,3,2], return_index=True)
# (array([1, 2, 3, 4, 6]), array([0, 1, 5, 3, 2]))

x = [1,2,6,4,2,3,2]
u, i = unique1d(x, return_inverse=True)
u
# array([1, 2, 3, 4, 6])

i
# array([0, 1, 4, 3, 1, 2, 1])

[u[p] for p in i]
# [1, 2, 6, 4, 2, 3, 2]]]></code>
      <code tags="vander vandermonde matrix"><![CDATA[x = array([1,2,3,5])
N=3
vander(x,N) # Vandermonde matrix of the vector x
# array([[ 1, 1, 1],
#        [ 4, 2, 1],
#        [ 9, 3, 1],
#        [25, 5, 1]])

column_stack([x**(N-1-i) for i in range(N)]) # to understand what a Vandermonde matrix contains
# array([[ 1, 1, 1],
#        [ 4, 2, 1],
#        [ 9, 3, 1],
#        [25, 5, 1]])]]></code>
      <code tags="var variance"><![CDATA[a = array([1,2,7])
a.var() # normalised with N (not N-1)
# 6.8888888888888875

a = array([[1,2,7],[4,9,6]])
a.var()
# 7.8055555555555571

a.var(axis=0) # the variance of each of the 3 columns
# array([ 2.25, 12.25, 0.25])

a.var(axis=1) # the variance of each of the 2 rows
# array([ 6.88888889, 4.22222222])]]></code>
      <code tags="vdot vector dot product"><![CDATA[x = array([1+2j,3+4j])
y = array([5+6j,7+8j])
vdot(x,y) # conj(x) * y = (1-2j)*(5+6j)+(3-4j)*(7+8j)
# (70-8j)]]></code>
      <code tags="vectorize convert to vector function"><![CDATA[def myfunc(x):
  if x >= 0: return x**2
  else: return -x

myfunc(2.) # works fine
# 4.0

myfunc(array([-2,2])) # doesn't work, try it...
# <snip>

vecfunc = vectorize(myfunc, otypes=[float]) # declare the return type as float
vecfunc(array([-2,2])) # works fine!
# array([ 2., 4.])]]></code>
      <code tags="view as type"><![CDATA[a = array([1., 2.])
a.view() # new array referring to the same data as 'a'
# array([ 1., 2.])

a.view(complex) # pretend that a is made up of complex numbers
# array([ 1.+2.j])

a.view(int) # view(type) is NOT the same as astype(type)!
# array([ 0, 1072693248, 0, 1073741824])

mydescr = dtype({'names': ['gender','age'], 'formats': ['S1', 'i2']})
a = array([('M',25),('F',30)], dtype = mydescr) # array with records
b = a.view(recarray) # convert to a record array, names are now attributes
# a['age'] # works with 'a' but not with 'b'
# array([25, 30], dtype=int16)

b.age # works with 'b' but not with 'a'
# array([25, 30], dtype=int16)]]></code>
      <code tags="vonmises von mises distribution random"><![CDATA[from numpy.random import *
vonmises(mu=1,kappa=1,size=(2,3)) # Von Mises distribution mean=1.0, kappa=1
# array([[ 0.81960554, 1.37470839, -0.15700173],
#        [ 1.2974554 , 2.94229797, 0.32462307]])

from pylab import * # histogram plot example
hist(vonmises(1,1,(10000)), 50)]]></code>
      <code tags="vsplit vertical split row wise"><![CDATA[a = array([[1,2],[3,4],[5,6],[7,8]])
vsplit(a,2) # split, row-wise, in 2 equal parts
# [array([[1, 2],
#        [3, 4]]), 
#  array([[5, 6],
#        [7, 8]])]

vsplit(a,[1,2]) # split, row-wise, before row 1 and before row 2
# [array([[1, 2]]), 
#  array([[3, 4]]), 
#  array([[5, 6],
#         [7, 8]])]]]></code>
      <code tags="vstack vertical stack concatenate row wise"><![CDATA[a = array([1,2])
b = array([[3,4],[5,6]])
vstack((a,b,a)) # only the first dimension of the arrays is allowed to be different
# array([[1, 2],
#        [3, 4],
#        [5, 6],
#        [1, 2]])]]></code>
      <code tags="weibull"><![CDATA[from numpy.random import *
weibull(a=1,size=(2,3)) # I think a is the shape parameter
# array([[ 0.08303065, 3.41486412, 0.67430149],
#        [ 0.41383893, 0.93577601, 0.45431195]])

from pylab import * # histogram plot example
hist(weibull(5, (1000)), 50)]]></code>
      <code tags="where conditional ternary operator select"><![CDATA[a = array([3,5,7,9])
b = array([10,20,30,40])
c = array([2,4,6,8])
where(a <= 6, b, c)
# array([10, 20, 6, 8])

where(a <= 6, b, -1)
# array([10, 20, -1, -1])

indices = where(a <= 6) # returns a tuple; the array contains indices.
indices
# (array([0, 1]),)

b[indices]
# array([10, 20])

b[a <= 6] # an alternative syntax
# array([10, 20])

d = array([[3,5,7,9],[2,4,6,8]])
where(d <= 6) # tuple with first all the row indices, then all the column indices
# (array([0, 0, 1, 1, 1]), array([0, 1, 0, 1, 2]))]]></code>
      <code tags="zeros"><![CDATA[zeros(5)
# array([ 0., 0., 0., 0., 0.])

zeros((2,3), int)
# array([[0, 0, 0],
#        [0, 0, 0]])]]></code>
      <code tags="zeros_like zeros like same shape"><![CDATA[a = array([[1,2,3],[4,5,6]])
zeros_like(a) # with zeros initialised array with the same shape and datatype as 'a'
# array([[0, 0, 0],
#        [0, 0, 0]])]]></code>
    </block>
  </block>
</block>